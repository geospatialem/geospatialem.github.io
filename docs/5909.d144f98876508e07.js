"use strict";var Ht=Object.defineProperty,Ut=Object.getOwnPropertySymbols,Xt=Object.prototype.hasOwnProperty,Yt=Object.prototype.propertyIsEnumerable,Wt=(Et,ft,R)=>ft in Et?Ht(Et,ft,{enumerable:!0,configurable:!0,writable:!0,value:R}):Et[ft]=R,Gt=(Et,ft)=>{for(var R in ft||(ft={}))Xt.call(ft,R)&&Wt(Et,R,ft[R]);if(Ut)for(var R of Ut(ft))Yt.call(ft,R)&&Wt(Et,R,ft[R]);return Et};(self.webpackChunksite=self.webpackChunksite||[]).push([[5909],{986:(Et,ft,R)=>{R.d(ft,{E:()=>J});const z=new(R(6879).Z);function J(nt){if(!z.hasBidiChar(nt))return[nt,!1];let Mt;return Mt="rtl"===z.checkContextual(nt)?"IDNNN":"ICNNN",[z.bidiTransform(nt,Mt,"VLYSN"),!0]}},36161:(Et,ft,R)=>{R.d(ft,{I:()=>z,v:()=>J});var V=R(21286);function z(k,v,j=0){const $=(0,V.uZ)(k,0,mt);for(let st=0;st<4;st++)v[j+st]=Math.floor(256*xt($*nt[st]))}function J(k,v=0){let j=0;for(let $=0;$<4;$++)j+=k[v+$]*Mt[$];return j}const nt=[1,256,65536,16777216],Mt=[1/256,1/65536,1/16777216,1/4294967296],mt=J(new Uint8ClampedArray([255,255,255,255]));function xt(k){return k-Math.floor(k)}},72283:(Et,ft,R)=>{R.d(ft,{zY:()=>It,v1:()=>bt,GP:()=>nt,wp:()=>j,XV:()=>Q,zv:()=>ct,QK:()=>lt,ov:()=>$,hh:()=>st,qh:()=>kt});var V=R(58817),z=R(91179),J=R(97373);function nt(D){const F=(0,V.d9)(D);return function v(D){D&&((0,z.oU)(D)?k(D.rings):(0,z.l9)(D)?k(D.paths):(0,z.aW)(D)&&xt(D.points))}(F),F}function Mt(D){if(D)for(let F=D.length-1;F>0;--F)D[F][0]-=D[F-1][0],D[F][1]-=D[F-1][1]}function mt(D){if(D)for(const F of D)Mt(F)}function xt(D){if(D){const F=D.length;for(let pt=1;pt<F;++pt)D[pt][0]+=D[pt-1][0],D[pt][1]+=D[pt-1][1]}}function k(D){if(D)for(const F of D)xt(F)}function j(D){D&&((0,z.oU)(D)?mt(D.rings):(0,z.l9)(D)?mt(D.paths):(0,z.aW)(D)&&Mt(D.points))}function $(D){if(D)for(const F of D)st(F)}function st(D){D&&D.reverse()}function Q(D,F,pt){return[D[0]+(F[0]-D[0])*pt,D[1]+(F[1]-D[1])*pt]}function lt(D){return!(!D||0===D.length)&&D[0][0]===D[D.length-1][0]&&D[0][1]===D[D.length-1][1]}function ct(D){return D[4]}function kt(D,F){D[4]=F}class bt{constructor(F,pt,Tt,zt){this.acceptPolygon=pt,this.acceptPolyline=Tt,this.geomUnitsPerPoint=zt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,F&&((0,z.oU)(F)?pt&&(this.multiPath=F.rings,this.isClosed=!0):(0,z.l9)(F)?Tt&&(this.multiPath=F.paths,this.isClosed=!1):(0,z.YX)(F)&&pt&&(this.multiPath=Lt(F).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new J.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const F=this.processPath(this.multiPath[this.pathIndex]);if(F)return F}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class It{constructor(F,pt,Tt,zt){this.inputGeometries=F,this.acceptPolygon=pt,this.acceptPolyline=Tt,this.geomUnitsPerPoint=zt,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let F=this.inputGeometries.next();for(;F;){if((0,z.oU)(F)?this.acceptPolygon&&(this.multiPath=F.rings,this.isClosed=!0):(0,z.l9)(F)?this.acceptPolyline&&(this.multiPath=F.paths,this.isClosed=!1):(0,z.YX)(F)&&this.acceptPolygon&&(this.multiPath=Lt(F).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}F=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const F=this.processPath(this.multiPath[this.pathIndex]);if(F)return F}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function Lt(D){return{rings:[[[D.xmin,D.ymin],[D.xmin,D.ymax],[D.xmax,D.ymax],[D.xmax,D.ymin],[D.xmin,D.ymin]]]}}},29214:(Et,ft,R)=>{R.d(ft,{M:()=>z}),R(58817);class z{constructor(Mt){this._geometry=Mt}next(){const Mt=this._geometry;return this._geometry=null,Mt}}},9631:(Et,ft,R)=>{R.d(ft,{h:()=>Ot,W:()=>Dt});var V=R(58817),z=R(91179),J=R(72283);let nt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new Mt(e,i,o)}}return f.instance=null,f})();class Mt{constructor(s,e,i){this._inputGeometries=s,this._angleTolerance=void 0!==e.angleTolerance?e.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let s=this._inputGeometries.next();for(;s;){if((0,z.oU)(s)){this._isClosed=!0;const e=(0,V.d9)(s);return this._processMultipath(e.rings),e}if((0,z.l9)(s)){this._isClosed=!1;const e=(0,V.d9)(s);return this._processMultipath(e.paths),e}if((0,z.YX)(s)){if(this._maxCosAngle)return s;this._isClosed=!0;const e=[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]];return this._processPath(e),{rings:[e]}}s=this._inputGeometries.next()}return null}_processMultipath(s){if(s)for(const e of s)this._processPath(e)}_processPath(s){if(s){let e,i,o,a,r,c,h=s.length,u=s[0];this._isClosed&&++h;for(let m=1;m<h;++m){let d;d=this._isClosed&&m===h-1?s[0]:s[m];const T=d[0]-u[0],A=d[1]-u[1],G=Math.sqrt(T*T+A*A);m>1&&G>0&&o>0&&(e*T+i*A)/G/o<=this._maxCosAngle&&(0,J.qh)(u,1),1===m&&(a=T,r=A,c=G),G>0&&(u=d,e=T,i=A,o=G)}this._isClosed&&o>0&&c>0&&(e*a+i*r)/c/o<=this._maxCosAngle&&(0,J.qh)(s[0],1)}}}const mt=.03;class xt{constructor(){this._path=[]}path(){return this._path}addPath(s,e){e||s.reverse(),Array.prototype.push.apply(this._path,s),e||s.reverse()}static mergePath(s,e){e&&Array.prototype.push.apply(s,e)}startPath(s){this._path.push(s)}lineTo(s){this._path.push(s)}close(){const s=this._path;s.length>1&&(s[0][0]===s[s.length-1][0]&&s[0][1]===s[s.length-1][1]||s.push([s[0][0],s[0][1]]))}}class k{constructor(s=0,e=!1){}normalize(s){const e=Math.sqrt(s[0]*s[0]+s[1]*s[1]);s[0]/=e,s[1]/=e}calculateLength(s,e){const i=e[0]-s[0],o=e[1]-s[1];return Math.sqrt(i*i+o*o)}calculateSegLength(s,e){return this.calculateLength(s[e],s[e+1])}calculatePathLength(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=this.calculateSegLength(s,o);return e}calculatePathArea(s){let e=0;const i=s?s.length:0;for(let o=0;o<i-1;++o)e+=(s[o+1][0]-s[o][0])*(s[o+1][1]+s[o][1]);return e/2}getCoord2D(s,e,i){return[s[0]+(e[0]-s[0])*i,s[1]+(e[1]-s[1])*i]}getSegCoord2D(s,e,i){return this.getCoord2D(s[e],s[e+1],i)}getAngle(s,e,i){return Math.atan2(e[1]-s[1],e[0]-s[0])}getSegAngle(s,e,i){return this.getAngle(s[e],s[e+1],i)}getAngleCS(s,e,i){const o=e[0]-s[0],a=e[1]-s[1],r=Math.sqrt(o*o+a*a);return r>0?[o/r,a/r]:[1,0]}getSegAngleCS(s,e,i){return this.getAngleCS(s[e],s[e+1],i)}cut(s,e,i,o){return[i<=0?s[e]:this.getSegCoord2D(s,e,i),o>=1?s[e+1]:this.getSegCoord2D(s,e,o)]}addSegment(s,e,i){i&&s.push(e[0]),s.push(e[1])}getSubCurve(s,e,i){const o=[];return this.appendSubCurve(o,s,e,i)?o:null}appendSubCurve(s,e,i,o){const a=e?e.length-1:0;let r=0,c=!0,h=0;for(;h<a;){const u=this.calculateSegLength(e,h);if(0!==u){if(c){if(r+u>i){let d=1,T=!1;r+u>=o&&(d=(o-r)/u,T=!0);const A=this.cut(e,h,(i-r)/u,d);if(A&&this.addSegment(s,A,c),T)break;c=!1}}else{if(r+u>o){const m=this.cut(e,h,0,(o-r)/u);m&&this.addSegment(s,m,c);break}this.addSegment(s,[e[h],e[h+1]],c)}r+=u,++h}else++h}return!0}getCIMPointAlong(s,e){const i=s?s.length-1:0;let o=0,a=-1;for(;a<i;){++a;const r=this.calculateSegLength(s,a);if(0!==r){if(o+r>e)return this.getCoord2D(s[a],s[a+1],(e-o)/r);o+=r}}return null}isEmpty(s,e){if(!s||s.length<=1)return!0;const i=s?s.length-1:0;let o=-1;for(;o<i;)if(++o,s[o+1][0]!==s[o][0]||s[o+1][1]!==s[o][1]||e&&s[o+1][2]!==s[o][2])return!1;return!0}offset(s,e,i,o,a){if(!s||s.length<2)return null;let r=0,c=s[r++],h=r;for(;r<s.length;){const T=s[r];T[0]===c[0]&&T[1]===c[1]||(r!==h&&(s[h]=s[r]),c=s[h++]),r++}const u=s[0][0]===s[h-1][0]&&s[0][1]===s[h-1][1];if(u&&--h,h<(u?3:2))return null;const m=[];c=u?s[h-1]:null;let d=s[0];for(let T=0;T<h;T++){const A=T===h-1?u?s[0]:null:s[T+1];if(c)if(A){const G=[A[0]-d[0],A[1]-d[1]];this.normalize(G);const H=[d[0]-c[0],d[1]-c[1]];this.normalize(H);const Z=H[0]*G[1]-H[1]*G[0],At=H[0]*G[0]+H[1]*G[1];if(Z>=0==e<=0){if(At<1){const vt=[G[0]-H[0],G[1]-H[1]];this.normalize(vt);const Ct=Math.sqrt((1+At)/2);if(Ct>1/o){const Pt=-Math.abs(e)/Ct;m.push([d[0]-vt[0]*Pt,d[1]-vt[1]*Pt])}}}else switch(i){case"Mitered":{const vt=Math.sqrt((1+At)/2);if(vt>0&&1/vt<o){const Ct=[G[0]-H[0],G[1]-H[1]];this.normalize(Ct);const Pt=Math.abs(e)/vt;m.push([d[0]-Ct[0]*Pt,d[1]-Ct[1]*Pt]);break}}case"Bevelled":m.push([d[0]+H[1]*e,d[1]-H[0]*e]),m.push([d[0]+G[1]*e,d[1]-G[0]*e]);break;case"Rounded":if(At<1){m.push([d[0]+H[1]*e,d[1]-H[0]*e]);const vt=Math.floor(2.5*(1-At));if(vt>0){const Ct=1/vt;let Pt=Ct;for(let Bt=1;Bt<vt;Bt++,Pt+=Ct){const Ft=[H[1]*(1-Pt)+G[1]*Pt,-H[0]*(1-Pt)-G[0]*Pt];this.normalize(Ft),m.push([d[0]+Ft[0]*e,d[1]+Ft[1]*e])}}m.push([d[0]+G[1]*e,d[1]-G[0]*e])}break;default:if(Z<0)m.push([d[0]+(H[1]+H[0])*e,d[1]+(H[1]-H[0])*e]),m.push([d[0]+(G[1]-G[0])*e,d[1]-(G[0]+G[1])*e]);else{const vt=Math.sqrt((1+Math.abs(At))/2),Ct=[G[0]-H[0],G[1]-H[1]];this.normalize(Ct);const Pt=e/vt;m.push([d[0]-Ct[0]*Pt,d[1]-Ct[1]*Pt])}}}else{const G=[d[0]-c[0],d[1]-c[1]];this.normalize(G),m.push([d[0]+G[1]*e,d[1]-G[0]*e])}else{const G=[A[0]-d[0],A[1]-d[1]];this.normalize(G),m.push([d[0]+G[1]*e,d[1]-G[0]*e])}c=d,d=A}return m.length<(u?3:2)?null:(u&&m.push([m[0][0],m[0][1]]),m)}}const v=1.7320508075688772;let st=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new Q(e,i,o)}}return f.instance=null,f})();class Q extends J.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new k,this._width=(void 0!==e.width?e.width:5)*i,this._arrowType=void 0!==e.geometricEffectArrowType?e.geometricEffectArrowType:"OpenEnded",this._offsetFlattenError=mt*i}processPath(s){switch(this._arrowType){case"OpenEnded":default:return this._constructSimpleArrow(s,!0);case"Block":return this._constructSimpleArrow(s,!1);case"Crossed":return this._constructCrossedArrow(s)}}_constructSimpleArrow(s,e){const i=this._curveHelper.calculatePathLength(s);let o=this._width;i<2*o&&(o=i/2);const a=this._curveHelper.getSubCurve(s,0,i-o);if(!a)return null;const r=o/2;if(this._curveHelper.isEmpty(a,!1))return null;const c=this._constructOffset(a,-r);if(!c)return null;const h=this._constructOffset(a,r);if(!h)return null;const u=this._constructArrowBasePoint(c,-r/2);if(!u)return null;const m=this._constructArrowBasePoint(h,r/2);if(!m)return null;const d=s[s.length-1];e||(this._makeControlPoint(h,!0),this._makeControlPoint(c,!0));const T=new xt;return T.addPath(h,!0),T.lineTo(m),this._makeControlPoint(T.path()),T.lineTo(d),this._makeControlPoint(T.path()),T.lineTo(u),this._makeControlPoint(T.path()),T.addPath(c,!1),e?{paths:[T.path()]}:(T.close(),{rings:[T.path()]})}_constructCrossedArrow(s){const e=this._curveHelper.calculatePathLength(s);let i=this._width;e<i*(1+v+1)&&(i=e/(1+v+1));const o=this._curveHelper.getSubCurve(s,0,e-i*(1+v));if(!o)return null;const a=i/2;if(this._curveHelper.isEmpty(o,!1))return null;const r=this._constructOffset(o,a);if(!r)return null;const c=this._constructOffset(o,-a);if(!c)return null;const h=this._curveHelper.getSubCurve(s,0,e-i);if(!h||this._curveHelper.isEmpty(h,!1))return null;const u=this._constructOffset(h,a);if(!u)return null;const m=this._constructOffset(h,-a);if(!m)return null;const d=u[u.length-1],T=this._constructArrowBasePoint(u,a/2);if(!T)return null;const A=m[m.length-1],G=this._constructArrowBasePoint(m,-a/2);if(!G)return null;const H=s[s.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(c,!1);const Z=new xt;return Z.addPath(r,!0),this._makeControlPoint(Z.path()),Z.lineTo(A),Z.lineTo(G),this._makeControlPoint(Z.path()),Z.lineTo(H),this._makeControlPoint(Z.path()),Z.lineTo(T),this._makeControlPoint(Z.path()),Z.lineTo(d),this._makeControlPoint(Z.path()),Z.addPath(c,!1),{paths:[Z.path()]}}_constructOffset(s,e){return this._curveHelper.offset(s,e,"Rounded",4,this._offsetFlattenError)}_constructArrowBasePoint(s,e){if(!s||s.length<2)return null;const i=s[s.length-2],o=s[s.length-1],a=[o[0]-i[0],o[1]-i[1]];return this._curveHelper.normalize(a),[o[0]+a[1]*e,o[1]-a[0]*e]}_makeControlPoint(s,e=!1){(0,J.qh)(e?s[0]:s[s.length-1],1)}}let lt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new ct(e,i,o)}}return f.instance=null,f})();class ct{constructor(s,e,i){this._inputGeometries=s,this._curveHelper=new k,this._size=(void 0!==e.size?e.size:1)*i,this._offsetFlattenError=mt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,z.YX)(s))if(this._size>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],this._size,"Rounded",4,this._offsetFlattenError);if(i)return{rings:[i]}}else{if(!(this._size<0))return s;if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._size>0)return{xmin:s.xmin-this._size,xmax:s.xmax+this._size,ymin:s.ymin-this._size,ymax:s.ymax+this._size}}if((0,z.oU)(s)){if(0===this._size)return s;const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,this._size,"Rounded",4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,z.l9)(s)&&this._size>0){const e=[];for(const i of s.paths)if(i&&i.length>1){const o=this._curveHelper.offset(i,this._size,"Rounded",4,this._offsetFlattenError),a=this._curveHelper.offset(i,-this._size,"Rounded",4,this._offsetFlattenError);if(o&&a){for(let r=a.length-1;r>=0;r--)o.push(a[r]);o.push([o[0][0],o[0][1]]),e.push(o)}}if(e.length)return{rings:e}}(0,z.wp)(s),s=this._inputGeometries.next()}return null}}let kt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new bt(e,i,o)}}return f.instance=null,f})();class bt{constructor(s,e,i){var o;this._default_point_size=20,this._inputGeometries=s,this._geomUnitsPerPoint=i,this._rule=null!=(o=e.rule)?o:"FullGeometry",this._default_size=this._default_point_size*i}next(){let s;for(;s=this._inputGeometries.next();){let e;if((0,z.wp)(s)?e=this._processGeom([[[s.x,s.y]]]):(0,z.aW)(s)?e=this._processGeom([s.points]):(0,z.l9)(s)?e=this._processGeom(s.paths):(0,z.oU)(s)&&(e=this._processGeom(s.rings)),e&&e.length)return{paths:e}}return null}_clone(s){return[s[0],s[1]]}_mid(s,e){return[(s[0]+e[0])/2,(s[1]+e[1])/2]}_mix(s,e,i,o){return[s[0]*e+i[0]*o,s[1]*e+i[1]*o]}_add(s,e){return[s[0]+e[0],s[1]+e[1]]}_add2(s,e,i){return[s[0]+e,s[1]+i]}_sub(s,e){return[s[0]-e[0],s[1]-e[1]]}_dist(s,e){return Math.sqrt((s[0]-e[0])*(s[0]-e[0])+(s[1]-e[1])*(s[1]-e[1]))}_norm(s){return Math.sqrt(s[0]*s[0]+s[1]*s[1])}_normalize(s,e=1){const i=e/this._norm(s);s[0]*=i,s[1]*=i}_leftPerpendicular(s){const i=-s[0];s[0]=s[1],s[1]=i}_leftPerp(s){return[s[1],-s[0]]}_rightPerpendicular(s){const i=s[0];s[0]=-s[1],s[1]=i}_rightPerp(s){return[-s[1],s[0]]}_dotProduct(s,e){return s[0]*e[0]+s[1]*e[1]}_crossProduct(s,e){return-(s[0]*e[1]-s[1]*e[0])}_rotateDirect(s,e,i){const a=s[0]*(i=-i)+s[1]*e;s[0]=s[0]*e-s[1]*i,s[1]=a}_makeCtrlPt(s){const e=[s[0],s[1]];return(0,J.qh)(e,1),e}_addAngledTicks(s,e,i,o){const a=this._sub(i,e);this._normalize(a);const r=this._crossProduct(a,this._sub(o,e));let c;c=r>0?this._rightPerp(a):this._leftPerp(a);const h=Math.abs(r)/2,u=[];u.push([e[0]+(c[0]-a[0])*h,e[1]+(c[1]-a[1])*h]),u.push(e),u.push(i),u.push([i[0]+(c[0]+a[0])*h,i[1]+(c[1]+a[1])*h]),s.push(u)}_addBezier2(s,e,i,o,a){if(0==a--)return void s.push(o);const r=this._mid(e,i),c=this._mid(i,o),h=this._mid(r,c);this._addBezier2(s,e,r,h,a),this._addBezier2(s,h,c,o,a)}_addBezier3(s,e,i,o,a,r){if(0==r--)return void s.push(a);const c=this._mid(e,i),h=this._mid(i,o),u=this._mid(o,a),m=this._mid(c,h),d=this._mid(h,u),T=this._mid(m,d);this._addBezier3(s,e,c,m,T,r),this._addBezier3(s,T,d,u,a,r)}_add90DegArc(s,e,i,o,a){const r=null!=a?a:this._crossProduct(this._sub(i,e),this._sub(o,e))>0,c=this._mid(e,i),h=this._sub(c,e);r?this._leftPerpendicular(h):this._rightPerpendicular(h),c[0]+=h[0],c[1]+=h[1],this._addBezier3(s,e,this._mix(e,.33333,c,.66667),this._mix(i,.33333,c,.66667),i,4)}_addArrow(s,e,i){const o=e[0],a=e[1],r=e[e.length-1],c=this._sub(o,a);this._normalize(c);const h=this._crossProduct(c,this._sub(r,a)),u=.5*h,m=this._leftPerp(c),d=[r[0]-m[0]*h,r[1]-m[1]*h],T=e.length-1,A=[];A.push(i?[-m[0],-m[1]]:m);let G=[-c[0],-c[1]];for(let H=1;H<T-1;H++){const Z=this._sub(e[H+1],e[H]);this._normalize(Z);const At=this._dotProduct(Z,G),vt=this._crossProduct(Z,G),Ct=Math.sqrt((1+At)/2),Pt=this._sub(Z,G);this._normalize(Pt),Pt[0]/=Ct,Pt[1]/=Ct,A.push(vt<0?[-Pt[0],-Pt[1]]:Pt),G=Z}A.push(this._rightPerp(G));for(let H=A.length-1;H>0;H--)s.push([e[H][0]+A[H][0]*u,e[H][1]+A[H][1]*u]);s.push([d[0]+A[0][0]*u,d[1]+A[0][1]*u]),s.push([d[0]+A[0][0]*h,d[1]+A[0][1]*h]),s.push(o),s.push([d[0]-A[0][0]*h,d[1]-A[0][1]*h]),s.push([d[0]-A[0][0]*u,d[1]-A[0][1]*u]);for(let H=1;H<A.length;H++)s.push([e[H][0]-A[H][0]*u,e[H][1]-A[H][1]*u])}_cp2(s,e,i){return s.length>=2?s[1]:this._add2(s[0],e*this._default_size,-i*this._default_size)}_cp3(s,e,i,o){if(s.length>=3)return s[2];const a=this._mix(s[0],1-i,e,i),r=this._sub(e,s[0]);return this._normalize(r),this._rightPerpendicular(r),[a[0]+r[0]*o*this._default_size,a[1]+r[1]*o*this._default_size]}_arrowPath(s){if(s.length>2)return s;const e=s[0],i=this._cp2(s,-4,0),o=this._sub(e,i);this._normalize(o);const a=this._rightPerp(o);return[e,i,[e[0]+(a[0]-o[0])*this._default_size,e[1]+(a[1]-o[1])*this._default_size]]}_arrowLastSeg(s){const e=s[0],i=this._cp2(s,-4,0);let o;if(s.length>=3)o=s[s.length-1];else{const a=this._sub(e,i);this._normalize(a);const r=this._rightPerp(a);o=[e[0]+(r[0]-a[0])*this._default_size,e[1]+(r[1]-a[1])*this._default_size]}return[i,o]}_processGeom(s){if(!s)return null;const e=[];for(const i of s){if(!i||0===i.length)continue;const o=i.length;let a=i[0];switch(this._rule){case"PerpendicularFromFirstSegment":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=[];h.push(c),h.push(this._mid(a,r)),e.push(h);break}case"ReversedFirstSegment":{const r=this._cp2(i,0,-1);e.push([r,a]);break}case"PerpendicularToSecondSegment":{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=[];h.push(this._mid(r,c)),h.push(a),e.push(h);break}case"SecondSegmentWithTicks":{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);let u;u=this._crossProduct(h,this._sub(a,r))>0?this._rightPerp(u):this._leftPerp(h);const m=[];m.push([r[0]+(u[0]-h[0])/3,r[1]+(u[1]-h[1])/3]),m.push(r),m.push(c),m.push([c[0]+(u[0]+h[0])/3,c[1]+(u[1]+h[1])/3]),e.push(m);break}case"DoublePerpendicular":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const m=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const d=[];d.push(a),d.push([c[0]+u[0]*m,c[1]+u[1]*m]),e.push(d);const T=[];T.push([c[0]-u[0]*m,c[1]-u[1]*m]),T.push(r),e.push(T);break}case"OppositeToFirstSegment":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const m=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const d=[];d.push([c[0]+u[0]*m,c[1]+u[1]*m]),d.push([c[0]-u[0]*m,c[1]-u[1]*m]),e.push(d);break}case"TriplePerpendicular":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(a,r),u=this._sub(h,c);this._normalize(u);const m=this._crossProduct(u,this._sub(a,c));this._leftPerpendicular(u);const d=[];d.push([c[0]+u[0]*m*.8,c[1]+u[1]*m*.8]),d.push([h[0]+.8*(a[0]-h[0]),h[1]+.8*(a[1]-h[1])]),e.push(d),e.push([c,h]);const T=[];T.push([c[0]-u[0]*m*.8,c[1]-u[1]*m*.8]),T.push([h[0]+.8*(r[0]-h[0]),h[1]+.8*(r[1]-h[1])]),e.push(T);break}case"HalfCircleFirstSegment":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(a,r);let u=this._sub(r,a);const m=Math.cos(Math.PI/18),d=Math.sin(Math.PI/18),T=Math.sqrt((1+m)/2),A=Math.sqrt((1-m)/2),G=[];let H;this._crossProduct(u,this._sub(c,a))>0?(G.push(a),u=this._sub(a,h),H=r):(G.push(r),u=this._sub(r,h),H=a),this._rotateDirect(u,T,A),u[0]/=T,u[1]/=T;for(let Z=1;Z<=18;Z++)G.push(this._add(h,u)),this._rotateDirect(u,m,d);G.push(H),e.push(G);break}case"HalfCircleSecondSegment":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,1,-1);let h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r))/2;this._leftPerpendicular(h);const m=[r[0]+h[0]*u,r[1]+h[1]*u];h=this._sub(r,m);const d=Math.cos(Math.PI/18);let T=Math.sin(Math.PI/18);u>0&&(T=-T);const A=[r];for(let G=1;G<=18;G++)this._rotateDirect(h,d,T),A.push(this._add(m,h));e.push(A);break}case"HalfCircleExtended":{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-1);let h;if(o>=4)h=i[3];else{const G=this._sub(a,r);h=this._add(c,G)}const u=this._dist(r,c)/2/.75,m=this._sub(r,a);this._normalize(m,u);const d=this._sub(c,h);this._normalize(d,u),e.push([h,c]);const A=[this._clone(c)];this._addBezier3(A,c,this._add(c,d),this._add(r,m),r,4),A.push(a),e.push(A);break}case"OpenCircle":{const r=this._cp2(i,-2,0),c=this._sub(r,a),h=Math.cos(Math.PI/18),u=-Math.sin(Math.PI/18),m=[r];for(let d=1;d<=33;d++)this._rotateDirect(c,h,u),m.push(this._add(a,c));e.push(m);break}case"CoverageEdgesWithTicks":{const r=this._cp2(i,0,-1);let c,h;if(o>=3)c=i[2];else{const T=this._sub(r,a),A=this._leftPerp(T);c=[a[0]+A[0]-.25*T[0],a[1]+A[1]-.25*T[1]]}if(o>=4)h=i[3];else{const T=this._mid(a,r),A=this._sub(a,r);this._normalize(A),this._leftPerpendicular(A);const G=this._crossProduct(A,this._sub(c,T));this._rightPerpendicular(A),h=[c[0]+A[0]*G*2,c[1]+A[1]*G*2]}const u=this._sub(r,a);let m,d;m=this._crossProduct(u,this._sub(c,a))>0?this._rightPerp(u):this._leftPerp(u),d=[],d.push(c),d.push(a),d.push([a[0]+(m[0]-u[0])/3,a[1]+(m[1]-u[1])/3]),e.push(d),m=this._crossProduct(u,this._sub(h,r))>0?this._rightPerp(m):this._leftPerp(u),d=[],d.push([r[0]+(m[0]+u[0])/3,r[1]+(m[1]+u[1])/3]),d.push(r),d.push(h),e.push(d);break}case"GapExtentWithDoubleTicks":{const r=this._cp2(i,0,2),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const u=this._sub(r,a);h=this._add(c,u)}this._addAngledTicks(e,a,r,this._mid(c,h)),this._addAngledTicks(e,c,h,this._mid(a,r));break}case"GapExtentMidline":{const r=this._cp2(i,2,0),c=this._cp3(i,r,0,1);let h;if(o>=4)h=i[3];else{const m=this._sub(r,a);h=this._add(c,m)}const u=[];u.push(this._mid(a,c)),u.push(this._mid(r,h)),e.push(u);break}case"Chevron":{const r=this._cp2(i,-1,-1);let c;if(o>=3)c=i[2];else{const h=this._sub(r,a);this._leftPerpendicular(h),c=this._add(a,h)}e.push([r,this._makeCtrlPt(a),c]);break}case"PerpendicularWithArc":{const r=this._cp2(i,0,-2),c=this._cp3(i,r,.5,-1);let h=this._sub(r,a);const u=this._norm(h);h[0]/=u,h[1]/=u;const m=this._crossProduct(h,this._sub(c,a));let d=this._dotProduct(h,this._sub(c,a));d<.05*u?d=.05*u:d>.95*u&&(d=.95*u);const T=[a[0]+h[0]*d,a[1]+h[1]*d];this._leftPerpendicular(h);let A=[];A.push([T[0]-h[0]*m,T[1]-h[1]*m]),A.push([T[0]+h[0]*m,T[1]+h[1]*m]),e.push(A);const G=[r[0]+h[0]*m,r[1]+h[1]*m];h=this._sub(r,G);const H=Math.cos(Math.PI/18);let Z=Math.sin(Math.PI/18);m<0&&(Z=-Z),A=[a,r];for(let At=1;At<=9;At++)this._rotateDirect(h,H,Z),A.push(this._add(G,h));e.push(A);break}case"ClosedHalfCircle":{const r=this._cp2(i,2,0),c=this._mid(a,r),h=this._sub(r,c),u=Math.cos(Math.PI/18),m=Math.sin(Math.PI/18),d=[a,r];for(let T=1;T<=18;T++)this._rotateDirect(h,u,m),d.push(this._add(c,h));e.push(d);break}case"TripleParallelExtended":{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-2),h=this._mid(a,r),u=this._sub(c,r);this._normalize(u);const m=Math.abs(this._crossProduct(u,this._sub(h,r)))/2,d=this._dist(r,c),T=[r,a];T.push([a[0]+u[0]*d*.5,a[1]+u[1]*d*.5]),e.push(T);const A=[];A.push([h[0]-u[0]*m,h[1]-u[1]*m]),A.push([h[0]+u[0]*d*.375,h[1]+u[1]*d*.375]),(0,J.qh)(A[A.length-1],1),A.push([h[0]+u[0]*d*.75,h[1]+u[1]*d*.75]),e.push(A),e.push([r,c]);break}case"ParallelWithTicks":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(c,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h),this._addAngledTicks(e,a,r,c),this._addAngledTicks(e,this._mix(a,1,h,u),this._mix(r,1,h,u),this._mid(a,r));break}case"Parallel":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._leftPerp(h),m=this._crossProduct(h,this._sub(c,a));let d=[a,r];e.push(d),d=[],d.push([a[0]+u[0]*m,a[1]+u[1]*m]),d.push([r[0]+u[0]*m,r[1]+u[1]*m]),e.push(d);break}case"PerpendicularToFirstSegment":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._mid(a,r),u=this._sub(r,a);this._normalize(u);const m=this._crossProduct(u,this._sub(c,a));this._leftPerpendicular(u);const d=[];d.push([h[0]-u[0]*m*.25,h[1]-u[1]*m*.25]),d.push([h[0]+u[0]*m*1.25,h[1]+u[1]*m*1.25]),e.push(d);break}case"ParallelOffset":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const m=[];m.push([a[0]-h[0]*u,a[1]-h[1]*u]),m.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(m);const d=[];d.push([a[0]+h[0]*u,a[1]+h[1]*u]),d.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(d);break}case"OffsetOpposite":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const m=[];m.push([a[0]-h[0]*u,a[1]-h[1]*u]),m.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(m);break}case"OffsetSame":{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,a);this._normalize(h);const u=this._crossProduct(h,this._sub(c,a));this._leftPerpendicular(h);const m=[];m.push([a[0]+h[0]*u,a[1]+h[1]*u]),m.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(m);break}case"CircleWithArc":{let r=this._cp2(i,3,0);const c=this._cp3(i,r,.5,-1);let h,u;if(o>=4)h=i[3],u=this._crossProduct(this._sub(h,r),this._sub(c,r))>0;else{h=r,u=this._crossProduct(this._sub(h,a),this._sub(c,a))>0;const G=24*this._geomUnitsPerPoint,H=this._sub(h,a);this._normalize(H,G);const Z=Math.sqrt(2)/2;this._rotateDirect(H,Z,u?Z:-Z),r=this._add(a,H)}const m=this._sub(r,a),d=Math.cos(Math.PI/18),T=Math.sin(Math.PI/18),A=[r];for(let G=1;G<=36;G++)this._rotateDirect(m,d,T),A.push(this._add(a,m));this._add90DegArc(A,r,h,c,u),(0,J.qh)(A[A.length-8],1),e.push(A);break}case"DoubleJog":{let r,c,h=this._cp2(i,-3,1);if(r=o>=3?i[2]:this._add(a,this._sub(a,h)),o>=4)c=i[3];else{const At=a;a=h,c=r;const vt=this._dist(a,At),Ct=this._dist(c,At);let Pt=30*this._geomUnitsPerPoint;.5*vt<Pt&&(Pt=.5*vt),.5*Ct<Pt&&(Pt=.5*Ct),h=this._mix(a,Pt/vt,At,(vt-Pt)/vt),r=this._mix(c,Pt/Ct,At,(Ct-Pt)/Ct)}const u=this._mid(a,h),m=this._mid(c,r),d=this._dist(a,h),T=this._dist(r,c);let A=Math.min(d,T)/8;A=Math.min(A,24*this._geomUnitsPerPoint);const G=Math.cos(Math.PI/4);let H=this._sub(a,h);this._normalize(H,A),this._crossProduct(H,this._sub(c,h))>0?this._rotateDirect(H,G,-G):this._rotateDirect(H,G,G);let Z=[];Z.push(h),Z.push(this._add(u,H)),Z.push(this._sub(u,H)),Z.push(a),e.push(Z),H=this._sub(c,r),this._normalize(H,A),this._crossProduct(H,this._sub(a,r))<0?this._rotateDirect(H,G,G):this._rotateDirect(H,G,-G),Z=[],Z.push(r),Z.push(this._add(m,H)),Z.push(this._sub(m,H)),Z.push(c),e.push(Z);break}case"PerpendicularOffset":{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(a,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],m=this._sub(this._mid(r,c),u);e.push([m,a]);break}case"LineExcludingLastSegment":{const r=this._arrowPath(i),c=[];let h=r.length-2;for(;h--;)c.push(r[h]);e.push(c);break}case"MultivertexArrow":{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!1),e.push(c);break}case"CrossedArrow":{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!0),e.push(c);break}case"ChevronArrow":{const[r,c]=this._arrowLastSeg(i),h=10*this._geomUnitsPerPoint,u=this._sub(a,r);this._normalize(u);const m=this._crossProduct(u,this._sub(c,r)),d=this._leftPerp(u),T=[c[0]-d[0]*m*2,c[1]-d[1]*m*2],A=[];A.push([c[0]+u[0]*h,c[1]+u[1]*h]),A.push(a),A.push([T[0]+u[0]*h,T[1]+u[1]*h]),e.push(A);break}case"ChevronArrowOffset":{const[r,c]=this._arrowLastSeg(i),h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h);const m=[c[0]-h[0]*u,c[1]-h[1]*u],d=[];d.push([m[0]+h[0]*u*.5,m[1]+h[1]*u*.5]),d.push(this._mid(m,a)),d.push([m[0]-h[0]*u*.5,m[1]-h[1]*u*.5]),e.push(d);break}case"PartialFirstSegment":{const[r,c]=this._arrowLastSeg(i),h=this._sub(a,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h),e.push([r,[c[0]-h[0]*u,c[1]-h[1]*u]]);break}case"Arch":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=this._sub(a,r),u=this._mix(c,1,h,.55),m=this._mix(c,1,h,-.55),d=[a];this._addBezier2(d,a,u,c,4),this._addBezier2(d,c,m,r,4),e.push(d);break}case"CurvedParallelTicks":{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(a,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],m=this._sub(this._mid(r,c),u),d=this._sub(this._mix(r,.75,c,.25),u),T=this._sub(this._mix(r,.25,c,.75),u),A=[r];this._addBezier2(A,r,d,m,3),this._addBezier2(A,m,T,c,3),e.push(A);for(let G=0;G<8;G++){const H=A[2*G+1],Z=[this._clone(H)];Z.push(this._add(H,[h[0]/4,h[1]/4])),e.push(Z)}break}case"Arc90Degrees":{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=[r];this._add90DegArc(h,r,a,c),e.push(h);break}default:e.push(i)}}return e}}let It=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new Lt(e,i,o)}}return f.instance=null,f})();class Lt extends J.zY{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new k,this._beginCut=(void 0!==e.beginCut?e.beginCut:1)*i,this._endCut=(void 0!==e.endCut?e.endCut:1)*i,this._middleCut=(void 0!==e.middleCut?e.middleCut:0)*i,this._invert=void 0!==e.invert&&e.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(s){const e=this._beginCut,i=this._endCut,o=this._middleCut,a=this._curveHelper.calculatePathLength(s),r=[];if(this._invert){if(0!==e||0!==i||0!==o)if(e+i+o>=a)r.push(s);else{let c=this._curveHelper.getSubCurve(s,0,e);c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(a-o),.5*(a+o)),c&&r.push(c),c=this._curveHelper.getSubCurve(s,a-i,i),c&&r.push(c)}}else if(0===e&&0===i&&0===o)r.push(s);else if(!(e+i+o>=a))if(0===o){const c=this._curveHelper.getSubCurve(s,e,a-i);c&&r.push(c)}else{let c=this._curveHelper.getSubCurve(s,e,.5*(a-o));c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(a+o),a-i),c&&r.push(c)}return 0===r.length?null:{paths:r}}}class F{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(s,e,i=!0){if(this._setEmpty(),!s||0===s.length)return!1;for(let o=0;o<s.length;o++){let a=Math.abs(s[o]);i&&a<1e-7&&(a=1e-7),this._values.push(a),this._length+=a}return e&&1&s.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(s){const e=this._values?this._values.length:0;for(let i=0;i<e;++i)this._values[i]*=s;this._length*=s,this.extPtGap*=s,this.ctrlPtGap*=s}addValue(s){this._length+=s,this._values.push(s)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class pt{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(s){s.segment=this.segment,s.segmentLength=this.segmentLength,s.abscissa=this.abscissa,s.isPathEnd=this.isPathEnd,s.isPartEnd=this.isPartEnd}}class Tt extends k{constructor(s=0,e=!1){super(s,e),this._tolerance=mt,this._currentPosition=new pt}updateTolerance(s){this._tolerance=mt*s}init(s,e,i=!0){return i?(this._patternLength=e.length(),this._partExtPtGap=e.extPtGap,this._partCtrlPtGap=e.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=s,this._seg=-1,this.setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(s,e=0){const i=new pt;return!!this._nextPosition(s,i,null,e)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(s){s.pt=this._getPoint(this._currentPosition);const[e,i]=this._getAngle(this._currentPosition);s.ca=e,s.sa=i}nextPointAndAngle(s,e,i=0){const o=new pt;if(!this._nextPosition(s,o,null,i))return!1;o.copyTo(this._currentPosition),e.pt=this._getPoint(o);const[a,r]=this._getAngle(o);return e.ca=a,e.sa=r,!0}nextCurve(s){if(0===s)return null;const e=[],i=new pt;return this._nextPosition(s,i,e,1)?(i.copyTo(this._currentPosition),e):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(s,e,i,o){if(this._currentPosition.isPathEnd)return!1;let a=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(a/=this._currentPosition.segmentLength),this._currentPosition.copyTo(e);e.abscissa+s*this._partLengthRatio>e.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===a){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,a));const r=this._path[e.segment+1];i.push([r[0],r[1]])}if(a=0,s-=(e.segmentLength-e.abscissa)/this._partLengthRatio,this._partSegCount)e.segment=this.nextSegment(),e.segmentLength=this.calculateSegLength(this._path,e.segment),e.abscissa=0,this._partSegCount--;else{if(!this.setPosAtNextPart())return 0!==o&&(e.segmentLength=this.calculateSegLength(this._path,e.segment),e.isPartEnd=!0,1===o?(e.abscissa=e.segmentLength,e.isPathEnd=!0):e.abscissa=e.segmentLength+s,!0);this._currentPosition.copyTo(e)}}if(e.abscissa+=s*this._partLengthRatio,i){if(0===i.length)if(0===a){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,a));const r=e.abscissa/e.segmentLength;if(1===r){const c=this._path[e.segment+1];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,r))}return this._partSegCount||Math.abs(e.abscissa-e.segmentLength)<this._tolerance&&(e.isPathEnd=this._partIsLast,e.isPartEnd=!0),!0}_getPoint(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_getAngle(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}setPosAtNextPart(){for(;this._partSegCount;)this.hasNextSegment()&&this.nextSegment(),this._partSegCount--;if(!this.hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this.hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this.nextSegment()),this._partSegCount++,1===(0,J.zv)(this._path[this.getEndPointIndex()])){this._partIsLast=!this.hasNextSegment();break}let s=this._partSegCount;for(;s;)this.previousSegment(),--s;this._currentPosition.segment=this.nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const e=this.getStartPointIndex();this._ctrlPtBegin=1===(0,J.zv)(this._path[e]);let i=e+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,J.zv)(this._path[i]),this._patternLength>0){const o=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,a=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(o+a))/this._patternLength);r<=0&&(r=o+a>0?0:1),this._partLengthRatio=this._partLength/(o+a+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}hasNextSegment(){return this._seg<this._path.length-2}previousSegment(){return--this._seg}nextSegment(){return++this._seg}getStartPointIndex(){return this._seg}getEndPointIndex(){return this._seg+1}}let zt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new ut(e,i,o)}}return f.instance=null,f})();class ut extends J.zY{constructor(s,e,i){var o,a;super(s,!0,!0),this._walker=new Tt,this._walker.updateTolerance(i),this._endings=e.lineDashEnding,this._customDashPos=-(null!=(o=e.offsetAlongLine)?o:0)*i,this._offsetAtEnd=(null!=(a=e.customEndingOffset)?a:0)*i,this._pattern=new F,this._pattern.init(e.dashTemplate,!0),this._pattern.scale(i)}processPath(s){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[s]};if(!this.iteratePath){let o=!0;switch(this._endings){case"HalfPattern":case"HalfGap":default:this._pattern.extPtGap=0;break;case"FullPattern":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case"FullGap":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case"NoConstraint":this.isClosed||(o=!1);break;case"Custom":this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const a=this._walker.calculatePathLength(s);if(this._pattern.isEmpty()||a<.1*this._pattern.length())return{paths:[s]};if(!this._walker.init(s,this._pattern,o))return{paths:[s]}}let e;if(this.iteratePath)e=this._pattern.nextValue();else{let o;switch(this._endings){case"HalfPattern":default:o=.5*this._pattern.firstValue();break;case"HalfGap":o=.5*-this._pattern.lastValue();break;case"FullGap":o=-this._pattern.lastValue();break;case"FullPattern":o=0;break;case"NoConstraint":case"Custom":o=-this._customDashPos}let a=o/this._pattern.length();a-=Math.floor(a),o=a*this._pattern.length(),this._pattern.reset(),e=this._pattern.nextValue();let r=!1;for(;o>=e;)o-=e,e=this._pattern.nextValue(),r=!r;e-=o,r?(this._walker.nextPosition(e),e=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(e),e=this._pattern.nextValue(),this._walker.nextPosition(e),e=this._pattern.nextValue())}let i=this._walker.nextCurve(e);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),xt.mergePath(i,this._firstCurve),this._firstCurve=null)):(e=this._pattern.nextValue(),!this._walker.nextPosition(e)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let L=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new B(e,i,o)}}return f.instance=null,f})();class B{constructor(s,e,i){switch(this._inputGeometries=s,this._curveHelper=new k,this._width=(void 0!==e.width?e.width:2)*i,e.method){case"Mitered":default:this._method="Mitered";break;case"Bevelled":this._method="Bevelled";break;case"Rounded":case"TrueBuffer":this._method="Rounded";break;case"Square":this._method="Square"}this._option=e.option,this._offsetFlattenError=mt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,z.YX)(s)&&this._width>0){if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)-2*this._width<0)return s;const e=[];return e.push([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]),e.push([[s.xmin+this._width,s.ymin+this._width],[s.xmax-this._width,s.ymin+this._width],[s.xmax-this._width,s.ymax-this._width],[s.xmin+this._width,s.ymax-this._width],[s.xmin+this._width,s.ymin+this._width]]),{rings:e}}if((0,z.oU)(s)&&this._width>0){const e=[];for(const i of s.rings){const o=this._curveHelper.calculatePathLength(i),a=this._curveHelper.offset(i,this._width,this._method,4,this._offsetFlattenError);a&&(o<0&&a.reverse(),e.push(a))}if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}}let U=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new K(e,i,o)}}return f.instance=null,f})();class K extends J.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new k,this._length=(void 0!==e.length?e.length:20)*i,this._angle=void 0!==e.angle?e.angle:225,this._position=void 0!==e.position?e.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(s){if(this._curveHelper.isEmpty(s,!1))return null;const e=s[0],i=s[s.length-1];this._curveHelper.normalize([i[0]-e[0],i[1]-e[1]]);const a=[e[0]+(i[0]-e[0])*this._position/100,e[1]+(i[1]-e[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let c=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(c=-c),this._mirror=!this._mirror,{paths:[[e,[a[0]-this._length/2*r,a[1]-this._length/2*c],[a[0]+this._length/2*r,a[1]+this._length/2*c],i]]}}}let O=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new n(e,i,o)}}return f.instance=null,f})();class n{constructor(s,e,i){this._inputGeometries=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?-e.offsetY*i:0}next(){let s=this._inputGeometries.next();for(;s;){if((0,z.YX)(s))return{xmin:s.xmin+this._offsetX,xmax:s.xmax+this._offsetX,ymin:s.ymin+this._offsetY,ymax:s.ymax+this._offsetY};if((0,z.oU)(s)){const e=(0,V.d9)(s);return this._moveMultipath(e.rings,this._offsetX,this._offsetY),e}if((0,z.l9)(s)){const e=(0,V.d9)(s);return this._moveMultipath(e.paths,this._offsetX,this._offsetY),e}if((0,z.aW)(s)){const e=(0,V.d9)(s);return this._movePath(e.points,this._offsetX,this._offsetY),e}if((0,z.wp)(s))return{x:s.x+this._offsetX,y:s.y+this._offsetY};s=this._inputGeometries.next()}return null}_moveMultipath(s,e,i){if(s)for(const o of s)this._movePath(o,e,i)}_movePath(s,e,i){if(s)for(const o of s)o[0]+=e,o[1]+=i}}let _=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o,a){return new M(e,i,o,a)}}return f.instance=null,f})();class M{constructor(s,e,i,o){var a;this._inputGeometries=s,this._curveHelper=new k,this._offset=(null!=(a=e.offset)?a:1)*i,o||(this._offset=-this._offset),this._method=e.method,this._option=e.option,this._offsetFlattenError=mt*i}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._offset)return s;if((0,z.YX)(s)){if("Rounded"===this._method&&this._offset>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],this._offset,this._method,4,this._offsetFlattenError);return i?{rings:[i]}:null}if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._offset>0)return{xmin:s.xmin-this._offset,xmax:s.xmax+this._offset,ymin:s.ymin-this._offset,ymax:s.ymax+this._offset}}if((0,z.oU)(s)){const e=[];for(const i of s.rings){const o=this._curveHelper.offset(i,this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{rings:e}}if((0,z.l9)(s)){const e=[];for(const i of s.paths){const o=this._curveHelper.offset(i,this._offset,this._method,4,this._offsetFlattenError);o&&e.push(o)}if(e.length)return{paths:e}}s=this._inputGeometries.next()}return null}}let y=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new b(e,i,o)}}return f.instance=null,f})();class b{constructor(s,e,i){this._inputGeometries=s,this._reverse=void 0===e.reverse||e.reverse}next(){let s=this._inputGeometries.next();for(;s;){if(!this._reverse)return s;if((0,z.l9)(s)){const e=(0,V.d9)(s);return(0,J.ov)(e.paths),e}s=this._inputGeometries.next()}return null}}var W=R(65401),S=R(32442);let N=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new rt(e,i,o)}}return f.instance=null,f})();class rt{constructor(s,e,i){this._inputGeometries=s,this._rotateAngle=void 0!==e.angle?-e.angle*Math.PI/180:0}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._rotateAngle)return s;const e=(0,W.Ue)();(0,S.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,z.YX)(s)){const a={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._rotateMultipath(a.rings,i,o),a}if((0,z.oU)(s)){const a=(0,V.d9)(s);return this._rotateMultipath(a.rings,i,o),a}if((0,z.l9)(s)){const a=(0,V.d9)(s);return this._rotateMultipath(a.paths,i,o),a}if((0,z.aW)(s)){const a=(0,V.d9)(s);return this._rotatePath(a.points,i,o),a}if((0,z.wp)(s))return s;s=this._inputGeometries.next()}return null}_rotateMultipath(s,e,i){if(s)for(const o of s)this._rotatePath(o,e,i)}_rotatePath(s,e,i){if(s){const o=Math.cos(this._rotateAngle),a=Math.sin(this._rotateAngle);for(const r of s){const c=r[0]-e,h=r[1]-i;r[0]=e+c*o-h*a,r[1]=i+c*a+h*o}}}}let ot=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new et(e,i,o)}}return f.instance=null,f})();class et{constructor(s,e,i){this._inputGeometries=s,this._xFactor=void 0!==e.xScaleFactor?e.xScaleFactor:1.15,this._yFactor=void 0!==e.yScaleFactor?e.yScaleFactor:1.15}next(){let s=this._inputGeometries.next();for(;s;){if(1===this._xFactor&&1===this._yFactor)return s;const e=(0,W.Ue)();(0,S.$P)(e,s);const i=(e[2]+e[0])/2,o=(e[3]+e[1])/2;if((0,z.YX)(s)){const a={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._scaleMultipath(a.rings,i,o),a}if((0,z.oU)(s)){const a=(0,V.d9)(s);return this._scaleMultipath(a.rings,i,o),a}if((0,z.l9)(s)){const a=(0,V.d9)(s);return this._scaleMultipath(a.paths,i,o),a}if((0,z.aW)(s)){const a=(0,V.d9)(s);return this._scalePath(a.points,i,o),a}if((0,z.wp)(s))return s;s=this._inputGeometries.next()}return null}_scaleMultipath(s,e,i){if(s)for(const o of s)this._scalePath(o,e,i)}_scalePath(s,e,i){if(s)for(const o of s){const r=(o[1]-i)*this._yFactor;o[0]=e+(o[0]-e)*this._xFactor,o[1]=i+r}}}let ht=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new wt(e,i,o)}}return f.instance=null,f})();class wt{constructor(s,e,i){this._inputGeometries=s,this._height=(void 0!==e.amplitude?e.amplitude:2)*i,this._period=(void 0!==e.period?e.period:3)*i,this._style=e.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new F,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new Tt,this._walker.updateTolerance(i)}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._height||0===this._period)return s;if((0,z.l9)(s)){const e=this._processGeom(s.paths);if(e.length)return{paths:e}}if((0,z.oU)(s)){const e=this._processGeom(s.rings);if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}_processGeom(s){const e=[];for(const i of s)if(this._walker.init(i,this._pattern))switch(this._style){case"Sinus":default:e.push(this._constructCurve(i,!1));break;case"Square":e.push(this._constructSquare(i));break;case"Triangle":e.push(this._constructTriangle(i));break;case"Random":e.push(this._constructCurve(i,!0))}else e.push(i);return e}_constructCurve(s,e){const i=new xt,o=this._walker.calculatePathLength(s);let a=Math.round(o/this._period);0===a&&(a=1);const h=this._period/16,u=1/(16*a+1),m=2*Math.PI*o/(o/a),d=2*Math.PI*Math.random(),T=2*Math.PI*Math.random(),A=2*Math.PI*Math.random(),G=.75-Math.random()/2,H=.75-Math.random()/2,Z={};this._walker.curPointAndAngle(Z),i.startPath(Z.pt);let At=0;for(;;){if(!this._walker.nextPointAndAngle(h,Z)){i.lineTo(s[s.length-1]);break}{const vt=At;let Ct;if(At+=u,e){const Pt=this._height/2*(1+.3*Math.sin(G*m*vt+d));Ct=Pt*Math.sin(m*vt+T),Ct+=Pt*Math.sin(H*m*vt+A),Ct/=2}else Ct=.5*this._height*Math.sin(.5*m*vt);i.lineTo([Z.pt[0]-Ct*Z.sa,Z.pt[1]+Ct*Z.ca])}}return i.path()}_constructSquare(s){const e=new xt,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca]),a=!0)}}if(!a){e.lineTo(this._walker.getPathEnd());break}}return e.path()}_constructTriangle(s){const e=new xt,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let o=!0;for(;;){let a=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period/2,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(this._walker.nextPosition(this._period/2)&&(o?(e.startPath(r.pt),o=!1):e.lineTo(r.pt),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca])),a=!0)}}if(!a){e.lineTo(this._walker.getPathEnd());break}}return e.path()}}var tt,f;(f=tt||(tt={})).NoConstraint="NoConstraint",f.WithMarkers="WithMarkers",f.WithFullGap="WithFullGap",f.WithHalfGap="WithHalfGap",f.Custom="Custom";let E=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new l(e,i,o)}}return f.instance=null,f})();class l extends J.v1{constructor(s,e,i){var o,a,r,c;super(s,!0,!0),this._geometryWalker=new Tt,this._geometryWalker.updateTolerance(i),this._angleToLine=null==(o=e.angleToLine)||o,this._offset=(null!=(a=e.offset)?a:0)*i,this._originalEndings=e.endings,this._offsetAtEnd=(null!=(r=e.customEndingOffset)?r:0)*i,this._position=-(null!=(c=e.offsetAlongLine)?c:0)*i,this._pattern=new F,this._pattern.init(e.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath)e=this._pattern.nextValue();else{this._endings=this._originalEndings===tt.WithFullGap&&this.isClosed?tt.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let o,a=!0;switch(this._endings){case tt.NoConstraint:o=-this._position,o=this._adjustPosition(o),a=!1;break;case tt.WithHalfGap:default:o=-this._pattern.lastValue()/2;break;case tt.WithFullGap:o=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case tt.WithMarkers:o=0;break;case tt.Custom:o=-this._position,o=this._adjustPosition(o),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(s,this._pattern,a))return null;this._pattern.reset();let r=0;for(;o>r;)o-=r,r=this._pattern.nextValue();r-=o,e=r,this.iteratePath=!0}const i={};return this._geometryWalker.nextPointAndAngle(e,i)?this._endings===tt.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===tt.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(s){let e=s/this._pattern.length();return e-=Math.floor(e),e*this._pattern.length()}}let p=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new g(e,i,o)}}return f.instance=null,f})();class g extends J.v1{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new k,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._type=e.extremityPlacement,this._position=void 0!==e.offsetAlongLine?e.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(s){let e;switch(this._type){case"Both":default:this._beginProcessed?(e=this._atExtremities(s,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(e=this._atExtremities(s,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case"JustBegin":e=this._atExtremities(s,this._position,!0);break;case"JustEnd":e=this._atExtremities(s,this._position,!1);case"None":}return e}_atExtremities(s,e,i){const o=s.length;if(o<2)return null;const r=i?o:-1,c=i?1:-1;let h,u=0,m=i?s[0]:s[o-1];for(let d=i?1:o-2;d!==r;d+=c){h=m,m=s[d];const T=this._curveHelper.calculateLength(h,m);if(u+T>e){const A=(e-u)/T,[G,H]=this._curveHelper.getAngleCS(h,m,A),Z=(0,J.XV)(h,m,A);return this.internalPlacement.setTranslate(Z[0]-this._offset*H,Z[1]+this._offset*G),this._angleToLine&&this.internalPlacement.setRotateCS(-G,-H),this.internalPlacement}u+=T}return null}}let x=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new w(e,i,o)}}return f.instance=null,f})();class w extends J.v1{constructor(s,e,i){super(s,!0,!0),this._walker=new Tt,this._walker.updateTolerance(i),this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._beginGap=void 0!==e.beginPosition?e.beginPosition*i:0,this._endGap=void 0!==e.endPosition?e.endPosition*i:0,this._flipFirst=void 0===e.flipFirst||e.flipFirst,this._pattern=new F,this._pattern.init(e.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath){const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(s)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(s,this._pattern,!1))return null;this._pattern.reset();const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h,this.iteratePath=!0}const i={};if(!this._walker.nextPointAndAngle(e,i,1))return this.iteratePath=!1,null;let a,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(a=i.ca,r=i.sa):(a=1,r=0),this._isFirst&&this._flipFirst&&(a=-a,r=-r),this.internalPlacement.setRotateCS(a,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var P=R(97373);let C=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new X(e,i,o)}}return f.instance=null,f})();class X{constructor(s,e,i){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=(void 0!==e.stepX?Math.abs(e.stepX):16)*i,this._stepY=(void 0!==e.stepY?Math.abs(e.stepY):16)*i,0!==this._stepX&&0!==this._stepY&&s&&function I(f){return void 0!==f.rings}(s)&&s.rings){if(this._gridType=void 0!==e.gridType?e.gridType:"Fixed","Random"===this._gridType)this._randomness=void 0!==e.randomness?e.randomness/100:1,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=void 0!==e.gridAngle?e.gridAngle:0,this._shiftOddRows=void 0!==e.shiftOddRows&&e.shiftOddRows,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new P.u,this._calculateMinMax(s),this._geometry=s}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(s){let e,i,o,a,r,c,h,u;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,r=c=Number.MAX_VALUE,h=u=-Number.MAX_VALUE;for(const m of s.rings){const d=m?m.length:0;for(let T=0;T<d;++T)e=m[T][0]-this._graphicOriginX-this._offsetX,i=m[T][1]-this._graphicOriginY-this._offsetY,o=this._cosAngle*e-this._sinAngle*i,a=this._sinAngle*e+this._cosAngle*i,r=Math.min(r,o),h=Math.max(h,o),c=Math.min(c,a),u=Math.max(u,a)}r+=this._graphicOriginX,h+=this._graphicOriginX,c+=this._graphicOriginY,u+=this._graphicOriginY,this._xMin=Math.round(r/this._stepX),this._xMax=Math.round(h/this._stepX),this._yMin=Math.round(c/this._stepY),this._yMax=Math.round(u/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let s=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(s+=.5*this._stepX);const e=this._currentY*this._stepY+this._offsetY;let i,o;return this._currentX++,"Random"===this._gridType?(i=this._graphicOriginX+s+this._stepX*this._randomness*(.5-Math.random())*2/3,o=this._graphicOriginY+e+this._stepY*this._randomness*(.5-Math.random())*2/3):(i=this._graphicOriginX+this._cosAngle*s+this._sinAngle*e,o=this._graphicOriginY-this._sinAngle*s+this._cosAngle*e),this._internalPlacement.setTranslate(i,o),this._internalPlacement}}}let q=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new gt(e,i,o)}}return f.instance=null,f})();class gt extends J.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new k,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._relativeTo=e.relativeTo,this._position=void 0!==e.startPointOffset?e.startPointOffset*i:0,this._epsilon=.001*i}processPath(s){const e=this._position;if("SegmentMidpoint"===this._relativeTo){for(this.iteratePath||(this._segmentCount=s.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const o=this._curSegment;this._curSegment++;const a=s[o-1],r=s[o],c=this._curveHelper.calculateLength(a,r);if(c<this._epsilon)continue;const h=.5+this._position/c,[u,m]=this._curveHelper.getAngleCS(a,r,h),d=(0,J.XV)(a,r,h);return this.internalPlacement.setTranslate(d[0]-this._offset*m,d[1]+this._offset*u),this._angleToLine&&this.internalPlacement.setRotateCS(u,m),this.internalPlacement}return this.iteratePath=!1,null}"LineEnd"===this._relativeTo&&(0,J.hh)(s);const i=this.onLine(s,e);return"LineEnd"===this._relativeTo&&(0,J.hh)(s),i}onLine(s,e){let i,o=!1;switch(this._relativeTo){case"LineMiddle":default:i=this._curveHelper.calculatePathLength(s)/2+e;break;case"LineBeginning":i=e;break;case"LineEnd":i=e,o=!0}const a=s.length;let r,c=0,h=s[0];for(let u=1;u<a;++u){r=h,h=s[u];const m=this._curveHelper.calculateLength(r,h);if(c+m>i){const d=(i-c)/m,[T,A]=this._curveHelper.getAngleCS(r,h,d),G=(0,J.XV)(r,h,d),H=o?this._offset:-this._offset;return this.internalPlacement.setTranslate(G[0]-H*A,G[1]+H*T),this._angleToLine&&(o?this.internalPlacement.setRotateCS(-T,-A):this.internalPlacement.setRotateCS(T,A)),this.internalPlacement}c+=m}return null}}let at=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new it(e,i,o)}}return f.instance=null,f})();class it extends J.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new k,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._endPoints=void 0===e.placeOnEndPoints||e.placeOnEndPoints,this._controlPoints=void 0===e.placeOnControlPoints||e.placeOnControlPoints,this._regularVertices=void 0===e.placeOnRegularVertices||e.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(s){if(this.iteratePath||(this._preparePath(s),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const e=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(e[2]);let i=e[0],o=e[1];if(0!==this._offset){const a=Math.cos(e[2]),r=Math.sin(e[2]);i-=this._offset*r,o+=this._offset*a}return this.internalPlacement.setTranslate(i,o),this._tagIterator++,this.internalPlacement}_preparePath(s){this._tags.length=0,this._tagIterator=0;const e=(0,J.QK)(s),i=s.length-1;let o,a,r=0,c=0,h=0,u=0,m=0;for(;r<i;){r++,o=s[r-1],a=s[r];const d=(0,J.zv)(o),T=(0,J.zv)(a);(this._angleToLine||0!==this._offset)&&(u=this._curveHelper.getAngle(o,a,0)),1===r?e?(c=u,h=d):(this._endPoints||this._controlPoints&&1===d)&&this._tags.push([o[0],o[1],u]):1===d?this._controlPoints&&this._tags.push([o[0],o[1],_t(m,u)]):this._regularVertices&&this._tags.push([o[0],o[1],_t(m,u)]),(this._angleToLine||0!==this._offset)&&(m=this._curveHelper.getAngle(o,a,1)),r===i&&(e?1===T||1===h?this._controlPoints&&this._tags.push([a[0],a[1],_t(m,c)]):this._regularVertices&&this._tags.push([a[0],a[1],_t(m,c)]):(this._endPoints||this._controlPoints&&1===T)&&this._tags.push([a[0],a[1],m]))}this._tagIterator=0}}function _t(f,s){const e=Math.PI;for(;Math.abs(s-f)>e+2e-15;)s-f>e?s-=2*e:s+=2*e;return(f+s)/2}let yt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,o){return new Rt(e,i,o)}}return f.instance=null,f})();class Rt{constructor(s,e,i){this._geometry=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._method=void 0!==e.method?e.method:"OnPolygon",this._internalPlacement=new P.u}next(){const s=this._geometry;return this._geometry=null,s&&function St(f){return void 0!==f.rings}(s)?this._polygonCenter(s):null}_polygonCenter(s){let e=!1;switch(this._method){default:{const i=(0,W.Ue)();(0,S.$P)(i,s),this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2-this._offsetY),e=!0;break}}return e?this._internalPlacement:null}}function Ot(f){if(!f)return null;switch(f.type){case"CIMGeometricEffectAddControlPoints":return nt.local();case"CIMGeometricEffectArrow":return st.local();case"CIMGeometricEffectBuffer":return lt.local();case"CIMGeometricEffectControlMeasureLine":return kt.local();case"CIMGeometricEffectCut":return It.local();case"CIMGeometricEffectDashes":return zt.local();case"CIMGeometricEffectDonut":return L.local();case"CIMGeometricEffectJog":return U.local();case"CIMGeometricEffectMove":return O.local();case"CIMGeometricEffectOffset":return _.local();case"CIMGeometricEffectReverse":return y.local();case"CIMGeometricEffectRotate":return N.local();case"CIMGeometricEffectScale":return ot.local();case"CIMGeometricEffectWave":return ht.local()}return null}function Dt(f){if(!f)return null;switch(f.type){case"CIMMarkerPlacementAlongLineSameSize":return E.local();case"CIMMarkerPlacementAtExtremities":return p.local();case"CIMMarkerPlacementAtRatioPositions":return x.local();case"CIMMarkerPlacementInsidePolygon":return C.local();case"CIMMarkerPlacementOnLine":return q.local();case"CIMMarkerPlacementOnVertices":return at.local();case"CIMMarkerPlacementPolygonCenter":return yt.local()}return null}},97373:(Et,ft,R)=>{R.d(ft,{u:()=>V});class V{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(nt,Mt){this.tx=nt,this.ty=Mt}setTranslateZ(nt){this.tz=nt}setRotateCS(nt,Mt){this.rz=void 0,this.rz_c=nt,this.rz_s=Mt}setRotate(nt){this.rz=nt,this.rz_c=void 0,this.rz_s=void 0}setRotateY(nt){this.ry=nt}setScale(nt){this.s=nt}setMeasure(nt){this.m=nt}}},57052:(Et,ft,R)=>{R.d(ft,{Z:()=>mt});var V=R(15861),z=R(84792),J=R(26584),nt=R(10699);class mt{constructor(){this._resourceMap=new Map,this._inFlightResourceMap=new Map}destroy(){this._inFlightResourceMap.clear(),this._resourceMap.clear()}getResource(v){var j;return null!=(j=this._resourceMap.get(v))?j:null}fetchResource(v,j){var $=this;return(0,V.Z)(function*(){const st={width:0,height:0},Q=$._resourceMap,lt=Q.get(v);if(lt)return st.width=lt.width,st.height=lt.height,st;let ct=$._inFlightResourceMap.get(v);return ct||(ct=function xt(k,v){if(k.includes(";base64,")){const j=new Image;return j.src=k,j.decode().then(()=>({ok:!0,value:j})).catch($=>(0,nt.D_)($)?{ok:!1,error:$}:{ok:!1,error:new J.Z("invalid-resource",`Could not fetch requested resource at ${k}`)})}return(0,z.default)(k,Gt({responseType:"image"},v)).then(j=>({ok:!0,value:j.data})).catch(j=>(0,nt.D_)(j)?{ok:!1,error:j}:{ok:!1,error:new J.Z("invalid-resource",`Could not fetch requested resource at ${k}`)})}(v,j),$._inFlightResourceMap.set(v,ct),ct=ct.then(kt=>{if($._inFlightResourceMap.delete(v),kt.ok){Q.set(v,kt.value);const bt=kt.value;return st.width=bt.width,st.height=bt.height,st}return st}),ct)})()}deleteResource(v){this._inFlightResourceMap.delete(v),this._resourceMap.delete(v)}}},89932:(Et,ft,R)=>{R.d(ft,{cD:()=>ut,uQ:()=>Tt,Tu:()=>zt,zA:()=>F,x1:()=>B,et:()=>K,g:()=>U});var V=R(986),z=R(63290),J=R(62208),nt=R(27899),Mt=R(23841),mt=R(65401),xt=R(32442),k=R(91179),v=R(29214),j=R(9631),$=R(97373),st=R(57052),Q=R(31375),lt=R(68937),ct=R(61261),kt=R(39351),bt=R(25797);const It=Math.PI/180,D=z.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class F{constructor(n){this._t=n}static createIdentity(){return new F([1,0,0,0,1,0])}clone(){return new F(this._t.slice())}transform(n){const _=this._t;return[_[0]*n[0]+_[1]*n[1]+_[2],_[3]*n[0]+_[4]*n[1]+_[5]]}static createScale(n,_){return new F([n,0,0,0,_,0])}scale(n,_){const M=this._t;return M[0]*=n,M[1]*=n,M[2]*=n,M[3]*=_,M[4]*=_,M[5]*=_,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(n,_){return new F([0,0,n,0,0,_])}translate(n,_){const M=this._t;return M[2]+=n,M[5]+=_,this}static createRotate(n){const _=Math.cos(n),M=Math.sin(n);return new F([_,-M,0,M,_,0])}rotate(n){return F.multiply(this,F.createRotate(n),this)}static multiply(n,_,M){const y=n._t,b=_._t,S=y[1]*b[0]+y[4]*b[1],N=y[2]*b[0]+y[5]*b[1]+b[2],rt=y[0]*b[3]+y[3]*b[4],ot=y[1]*b[3]+y[4]*b[4],et=y[2]*b[3]+y[5]*b[4]+b[5],ht=M._t;return ht[0]=y[0]*b[0]+y[3]*b[1],ht[1]=S,ht[2]=N,ht[3]=rt,ht[4]=ot,ht[5]=et,M}invert(){const n=this._t;let _=n[0]*n[4]-n[1]*n[3];return 0===_?new F([0,0,0,0,0,0]):(_=1/_,new F([n[4]*_,-n[1]*_,(n[1]*n[5]-n[2]*n[4])*_,-n[3]*_,n[0]*_,(n[2]*n[3]-n[0]*n[5])*_]))}}class pt{constructor(n,_){this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._flippedYs=!1,this._placementPool=new nt.Z($.u,null,null,100),this._earlyReturn=!1,this._mapRotation=0,this._resourceManager=n||new st.Z,this._transfos.push(_||F.createIdentity()),this._sizeTransfos.push(_?_.scaleRatio():1)}setTransform(n,_){this._transfos=[n||F.createIdentity()],this._sizeTransfos=[_||(n?n.scaleRatio():1)]}setGeomUnitsPerPoint(n){this._geomUnitsPerPoint=n}setFlippedYs(n){this._flippedYs=n}transformPt(n){return this._transfos[this._transfos.length-1].transform(n)}transformSize(n){return n*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(n){return this._transfos[this._transfos.length-1].invert().transform(n)}reverseTransformSize(n){return n/this._sizeTransfos[this._sizeTransfos.length-1]}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}flippedYs(){return!this.isEmbedded()&&this._flippedYs}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(n,_){const M=_?n.scaleRatio():1;F.multiply(n,this.back(),n),this._transfos.push(n),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*M)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(n,_){if(n)switch(n.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(n,_);break;case"CIMTextSymbol":this.drawTextSymbol(n,_)}}drawMultiLayerSymbol(n,_){if(!n)return;const M=n.symbolLayers;if(!M)return;const y=n.effects;if(y&&y.length>0){const b=this.executeEffects(y,_);if(b){let W=b.next();for(;W;)this.drawSymbolLayers(M,W),W=b.next()}}else this.drawSymbolLayers(M,_)}executeEffects(n,_){let M=new v.M(_);for(const y of n){const b=(0,j.h)(y);b&&(M=b.execute(M,y,this.geomUnitsPerPoint(),this.flippedYs()))}return M}drawSymbolLayers(n,_){let M=n.length;for(;M--;){const y=n[M];if(!y||!1===y.enable)continue;const b=y.effects;if(b&&b.length>0){const W=this.executeEffects(b,_);if(W){let S=null;for(;(S=W.next())&&(this.drawSymbolLayer(y,S),!this._earlyReturn););}}else this.drawSymbolLayer(y,_);if(this._earlyReturn)return}}drawSymbolLayer(n,_){switch(n.type){case"CIMSolidFill":this.drawSolidFill(_,n.color);break;case"CIMHatchFill":this.drawHatchFill(_,n);break;case"CIMPictureFill":this.drawPictureFill(_,n);break;case"CIMGradientFill":this.drawGradientFill(_,n);break;case"CIMSolidStroke":this.drawSolidStroke(_,n.color,n.width,n.capStyle,n.joinStyle,n.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(_,n);break;case"CIMGradientStroke":this.drawGradientStroke(_,n);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(n,_)}}drawHatchFill(n,_){const M=this._buildHatchPolyline(_,n,this.geomUnitsPerPoint());M&&(this.pushClipPath(n),this.drawMultiLayerSymbol(_.lineSymbol,M),this.popClipPath())}drawPictureFill(n,_){}drawGradientFill(n,_){}drawPictureStroke(n,_){}drawGradientStroke(n,_){}drawMarkerLayer(n,_){const M=n.markerPlacement;if(M){const y=(0,j.W)(M);if(y){const b="CIMMarkerPlacementInsidePolygon"===M.type;b&&this.pushClipPath(_);const W=y.execute(_,M,this.geomUnitsPerPoint());if(W){let S=null;for(;(S=W.next())&&(this.drawMarker(n,S),!this._earlyReturn););}b&&this.popClipPath()}}else{const y=this._placementPool.acquire();if((0,k.wp)(_))y.tx=_.x,y.ty=_.y,this.drawMarker(n,y);else for(const b of _.points)if(y.tx=b[0],y.ty=b[1],this.drawMarker(n,y),this._earlyReturn)break;this._placementPool.release(y)}}drawMarker(n,_){switch(n.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(n,_);break;case"CIMVectorMarker":this.drawVectorMarker(n,_)}}drawPictureMarker(n,_){var M,y,b,W,S;if(!n)return;const N=this._resourceManager.getResource(n.url),rt=null!=(M=n.size)?M:10;if((0,J.Wi)(N)||rt<=0)return;const ot=N.width,et=N.height;if(!ot||!et)return;const ht=ot/et,wt=null!=(y=n.scaleX)?y:1,tt=F.createIdentity(),E=n.anchorPoint;if(E){let P=E.x,I=E.y;"Absolute"!==n.anchorPointUnits&&(P*=rt*ht*wt,I*=rt),tt.translate(-P,-I)}let l=null!=(b=n.rotation)?b:0;n.rotateClockwise&&(l=-l),this._mapRotation&&(l+=this._mapRotation),l&&tt.rotate(l*It);let p=null!=(W=n.offsetX)?W:0,g=null!=(S=n.offsetY)?S:0;if(p||g){if(this._mapRotation){const P=It*this._mapRotation,I=Math.cos(P),C=Math.sin(P),X=p*C+g*I;p=p*I-g*C,g=X}tt.translate(p,g)}const x=this.geomUnitsPerPoint();1!==x&&tt.scale(x,x);const w=_.getAngle();w&&tt.rotate(w),tt.translate(_.tx,_.ty),this.push(tt,!1),this.drawImage(n.url,rt,n.scaleX),this.pop()}drawVectorMarker(n,_){var M,y,b,W;if(!n)return;const S=n.markerGraphics;if(!S)return;const N=null!=(M=n.size)?M:10,rt=n.frame,ot=rt?rt.ymax-rt.ymin:0,et=N&&ot?N/ot:1,ht=F.createIdentity();rt&&ht.translate(.5*-(rt.xmax+rt.xmin),.5*-(rt.ymax+rt.ymin));const wt=n.anchorPoint;if(wt){let x=wt.x,w=wt.y;"Absolute"!==n.anchorPointUnits?rt&&(x*=rt.xmax-rt.xmin,w*=rt.ymax-rt.ymin):(x/=et,w/=et),ht.translate(-x,-w)}1!==et&&ht.scale(et,et);let tt=null!=(y=n.rotation)?y:0;n.rotateClockwise&&(tt=-tt),this._mapRotation&&(tt+=this._mapRotation),tt&&ht.rotate(tt*It);let E=null!=(b=n.offsetX)?b:0,l=null!=(W=n.offsetY)?W:0;if(E||l){if(this._mapRotation){const x=It*this._mapRotation,w=Math.cos(x),P=Math.sin(x),I=E*P+l*w;E=E*w-l*P,l=I}ht.translate(E,l)}const p=this.geomUnitsPerPoint();1!==p&&ht.scale(p,p);const g=_.getAngle();g&&ht.rotate(g),ht.translate(_.tx,_.ty),this.push(ht,n.scaleSymbolsProportionally);for(const x of S)if(x&&x.symbol&&x.geometry||D.error("Invalid marker graphic",x),this.drawSymbol(x.symbol,x.geometry),this._earlyReturn)break;this.pop()}drawTextSymbol(n,_){var M,y,b,W;if(!n||!(0,k.wp)(_)||(null!=(M=n.height)?M:10)<=0)return;const S=F.createIdentity();let N=null!=(y=n.angle)?y:0;N=-N,N&&S.rotate(N*It);const rt=null!=(b=n.offsetX)?b:0,ot=null!=(W=n.offsetY)?W:0;(rt||ot)&&S.translate(rt,ot);const et=this.geomUnitsPerPoint();1!==et&&S.scale(et,et),S.translate(_.x,_.y),this.push(S,!1),this.drawText(n),this.pop()}_buildHatchPolyline(n,_,M){let y=(void 0!==n.separation?n.separation:4)*M,b=void 0!==n.rotation?n.rotation:0;if(0===y)return null;y<0&&(y=-y);let W=0;const S=.5*y;for(;W>S;)W-=y;for(;W<-S;)W+=y;const N=(0,mt.Ue)();(0,xt.$P)(N,_),N[0]-=S,N[1]-=S,N[2]+=S,N[3]+=S;const rt=[[N[0],N[1]],[N[0],N[3]],[N[2],N[3]],[N[2],N[1]]];for(;b>180;)b-=180;for(;b<0;)b+=180;const ot=Math.cos(b*It),et=Math.sin(b*It),ht=-y*et,wt=y*ot;let tt,E,l,p;W=(void 0!==n.offsetX?n.offsetX*M:0)*et-(void 0!==n.offsetY?n.offsetY*M:0)*ot,tt=l=Number.MAX_VALUE,E=p=-Number.MAX_VALUE;for(const X of rt){const Y=X[0],q=X[1],gt=ot*Y+et*q,at=-et*Y+ot*q;tt=Math.min(tt,gt),l=Math.min(l,at),E=Math.max(E,gt),p=Math.max(p,at)}l=Math.floor(l/y)*y;let g=ot*tt-et*l-ht*W/y,x=et*tt+ot*l-wt*W/y,w=ot*E-et*l-ht*W/y,P=et*E+ot*l-wt*W/y;const I=1+Math.round((p-l)/y),C=[];for(let X=0;X<I;X++)g+=ht,x+=wt,w+=ht,P+=wt,C.push([[g,x],[w,P]]);return{paths:C}}}class Tt extends pt{constructor(n,_){super(n,_),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new Q.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,mt.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(n){if(n&&!(this._clipCount>0))if((0,k.oU)(n))this._processPath(n.rings,0);else if((0,k.l9)(n))this._processPath(n.paths,0);else if((0,k.YX)(n)){const _=L(n);_&&this._processPath(_.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(n,_,M){if(!n||this._clipCount>0)return;const y=.5*this.transformSize(M);if((0,k.oU)(n))this._processPath(n.rings,y);else if((0,k.l9)(n))this._processPath(n.paths,y);else if((0,k.YX)(n)){const b=L(n);b&&this._processPath(b.rings,y)}else console.error("drawSolidStroke unexpected geometry type!")}pushClipPath(n){this.drawSolidFill(n),++this._clipCount}popClipPath(){--this._clipCount}drawImage(n,_,M){let y=M*_,b=_;const W=this._resourceManager.getResource(n);!_&&(0,J.pC)(W)&&(y=M*W.width,b=W.height),this._merge(this.transformPt([-y/2,-b/2]),0),this._merge(this.transformPt([-y/2,b/2]),0),this._merge(this.transformPt([y/2,-b/2]),0),this._merge(this.transformPt([y/2,b/2]),0)}drawText(n){this._textRasterizer||(this._textRasterizer=new lt.d)}_processPath(n,_){if(n)for(const M of n){const y=M?M.length:0;if(y>1){this._merge(this.transformPt(M[0]),_);for(let b=1;b<y;++b)this._merge(this.transformPt(M[b]),_)}}}_merge(n,_){n[0]-_<this._xmin&&(this._xmin=n[0]-_),n[0]+_>this._xmax&&(this._xmax=n[0]+_),n[1]-_<this._ymin&&(this._ymin=n[1]-_),n[1]+_>this._ymax&&(this._ymax=n[1]+_)}}class zt extends pt{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0}hitTest(n,_,M,y,b,W){const S=W*(0,Mt.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(S),this._searchPoint=[(n[0]+n[2])/2,(n[1]+n[3])/2],this._searchDistPoint=(n[2]-n[0])/2/S,this._textInfo=y,this._mapRotation=_&&("CIMPointSymbol"===_.type&&"Map"!==_.angleAlignment||"CIMTextSymbol"===_.type)?b:0,this._earlyReturn=!1,this.drawSymbol(_,M),this._earlyReturn}drawSolidFill(n,_){this._hitTestFill(n)}drawHatchFill(n,_){this._hitTestFill(n)}drawPictureFill(n,_){this._hitTestFill(n)}drawGradientFill(n,_){this._hitTestFill(n)}drawSolidStroke(n,_,M,y,b,W){this._hitTestStroke(n,M)}drawPictureStroke(n,_){this._hitTestStroke(n,_.width)}drawGradientStroke(n,_){this._hitTestStroke(n,_.width)}pushClipPath(n){}popClipPath(){}drawImage(n,_,M){const y=this._resourceManager.getResource(n);if((0,J.Wi)(y)||0===y.height||0===_)return;const b=_*this.geomUnitsPerPoint(),W=b*M*(y.width/y.height),S=this.reverseTransformPt(this._searchPoint),N=this._searchDistPoint;Math.abs(S[0])<W/2+N&&Math.abs(S[1])<b/2+N&&(this._earlyReturn=!0)}drawText(n){var _,M;const y=this._textInfo;if(!y)return;const b=y.get(n);if(!b)return;const{text:W,mosaicItem:S}=b;if(!S||0===S.glyphMosaicItems.length)return;const N=null!=(_=n.height)?_:10,rt=K(n.lineGapType,null!=(M=n.lineGap)?M:0,N),ot=(0,V.E)(W)[1],ht=(0,bt.Nr)(S.glyphMosaicItems,ot,{scale:N/kt.Ex,angle:0,xOffset:0,yOffset:0,hAlign:B(n.horizontalAlignment),vAlign:U(n.verticalAlignment),maxLineWidth:512,lineHeight:kt.xm*Math.max(.25,Math.min(rt||1,4)),decoration:n.font.decoration||"none",isCIM:!0}),wt=this.reverseTransformPt(this._searchPoint),tt=wt[0],E=wt[1];for(const l of ht.glyphs)if(tt>l.xTopLeft&&tt<l.xBottomRight&&E>-l.yBottomRight&&E<-l.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(n){let _=null;if((0,k.YX)(n))_=[[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]]];else if((0,k.oU)(n))_=n.rings;else{if(!(0,k.l9)(n))return;_=n.paths}const M=this.reverseTransformPt(this._searchPoint);this._pointInPolygon(M,_)&&(this._earlyReturn=!0);const y=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(M,_,y)&&(this._earlyReturn=!0)}_hitTestStroke(n,_){let M=null;if((0,k.YX)(n))M=[[[n.xmin,n.ymin],[n.xmin,n.ymax],[n.xmax,n.ymax],[n.xmax,n.ymin],[n.xmin,n.ymin]]];else if((0,k.oU)(n))M=n.rings;else{if(!(0,k.l9)(n))return;M=n.paths}const y=this.reverseTransformPt(this._searchPoint),b=_*this.geomUnitsPerPoint(),W=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(y,M,b/2+W)&&(this._earlyReturn=!0)}_pointInPolygon(n,_){let M=0;for(const y of _){const b=y.length;for(let W=1;W<b;++W){const S=y[W-1],N=y[W];S[1]>n[1]!=N[1]>n[1]&&((N[0]-S[0])*(n[1]-S[1])-(N[1]-S[1])*(n[0]-S[0])>0?M++:M--)}}return 0!==M}_nearLine(n,_,M){for(const y of _){const b=y.length;for(let W=1;W<b;++W){const S=y[W-1],N=y[W];let rt=(N[0]-S[0])*(N[0]-S[0])+(N[1]-S[1])*(N[1]-S[1]);if(0!==rt&&(rt=Math.sqrt(rt),Math.abs(((N[0]-S[0])*(n[1]-S[1])-(N[1]-S[1])*(n[0]-S[0]))/rt)<M)){const et=((N[0]-S[0])*(n[0]-S[0])+(N[1]-S[1])*(n[1]-S[1]))/rt;if(et>-M&&et<rt+M)return!0}}}return!1}}class ut extends pt{constructor(n,_,M){super(_,M),this._ctx=n}drawSolidFill(n,_){if(!n)return;if((0,k.oU)(n))this._buildPath(n.rings,!0);else if((0,k.l9)(n))this._buildPath(n.paths,!0);else if((0,k.YX)(n))this._buildPath(L(n).rings,!0);else{if(!(0,k.aW)(n))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const M=this._ctx;M.fillStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",M.fill("evenodd")}drawSolidStroke(n,_,M,y,b,W){if(!n||!_||0===M)return;if((0,k.oU)(n))this._buildPath(n.rings,!0);else if((0,k.l9)(n))this._buildPath(n.paths,!1);else{if(!(0,k.YX)(n))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(L(n).rings,!0)}const S=this._ctx;S.strokeStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",S.lineWidth=this.transformSize(M)+.5,this._setCapStyle(y),this._setJoinStyle(b),S.miterLimit=W,S.stroke()}pushClipPath(n){if(this._ctx.save(),(0,k.oU)(n))this._buildPath(n.rings,!0);else if((0,k.l9)(n))this._buildPath(n.paths,!0);else{if(!(0,k.YX)(n))return;this._buildPath(L(n).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(n,_,M){const y=this._resourceManager.getResource(n);if((0,J.Wi)(y))return;const b=this._ctx,W=b.canvas.width,S=b.canvas.height;let N=_*M*(y.width/y.height),rt=M*_;_||(N=M*y.width,rt=M*y.height),this._ctx.drawImage(y,0,0,y.width,y.height,0,0,Math.min(this.transformSize(N),W),Math.min(this.transformSize(rt),S))}drawText(n){this._textRasterizer||(this._textRasterizer=new lt.d)}_buildPath(n,_){const M=this._ctx;if(M.beginPath(),n)for(const y of n){const b=y?y.length:0;if(b>1){let W=this.transformPt(y[0]);M.moveTo(W[0],W[1]);for(let S=1;S<b;++S)W=this.transformPt(y[S]),M.lineTo(W[0],W[1]);_&&M.closePath()}}}_setCapStyle(n){switch(n){case"Butt":this._ctx.lineCap="butt";break;case"Round":this._ctx.lineCap="round";break;case"Square":this._ctx.lineCap="square"}}_setJoinStyle(n){switch(n){case"Bevel":this._ctx.lineJoin="bevel";break;case"Round":this._ctx.lineJoin="round";break;case"Miter":this._ctx.lineJoin="miter"}}}const L=O=>O?{spatialReference:O.spatialReference,rings:[[[O.xmin,O.ymin],[O.xmin,O.ymax],[O.xmax,O.ymax],[O.xmax,O.ymin],[O.xmin,O.ymin]]]}:null,B=O=>{switch(O){case"Left":return ct.M7.Left;case"Right":return ct.M7.Right;case"Center":case"Justify":return ct.M7.Center}},U=O=>{switch(O){case"Top":return ct.TR.Top;case"Center":return ct.TR.Center;case"Bottom":return ct.TR.Bottom;case"Baseline":return ct.TR.Baseline}},K=(O,n,_)=>{switch(O){case"ExtraLeading":return 1+n/_;case"Multiple":return n;case"Exact":return n/_}}},35909:(Et,ft,R)=>{R.d(ft,{IV:()=>K,B$:()=>O,E0:()=>_,fN:()=>n,U1:()=>et,rW:()=>zt});var V=R(91558),z=R(986),J=R(36161),nt=R(58817),Mt=R(63290),mt=R(21286),xt=R(62208),k=R(23841),v=R(65401),j=R(32442),$=R(97373),st=R(89932),Q=R(80991),lt=R(86575),ct=R(39351),kt=R(25797);const bt=Math.PI,It=bt/2,F=96/72,pt=Math.PI/180,Tt=Mt.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function zt(E){if(!E||!E.type)return null;let l;switch(E.type){case"cim":return E.data;case"web-style":return E;case"simple-marker":l=O.fromSimpleMarker(E);break;case"picture-marker":l=O.fromPictureMarker(E);break;case"simple-line":l=O.fromSimpleLineSymbol(E);break;case"simple-fill":l=O.fromSimpleFillSymbol(E);break;case"picture-fill":l=O.fromPictureFillSymbol(E);break;case"text":l=O.fromTextSymbol(E)}return{type:"CIMSymbolReference",symbol:l}}function ut(E,l){switch(l.type){case"CIMSymbolReference":return ut(E,l.symbol);case"CIMPointSymbol":case"CIMTextSymbol":E.drawSymbol(l,{x:0,y:0});break;case"CIMLineSymbol":E.drawSymbol(l,{paths:[[[0,0],[0,1]]]});break;case"CIMPolygonSymbol":E.drawSymbol(l,{rings:[[[0,0],[0,1],[0,0]]]});break;case"CIMVectorMarker":{const p=new $.u;E.drawMarker(l,p);break}}return E.envelope()}function L(E){if(!E)return 0;switch(E.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(E.offset);default:return 0}}function B(E){if(!E)return 0;switch(E.type){case"CIMGeometricEffectArrow":return Math.abs(.5*E.width);case"CIMGeometricEffectBuffer":return Math.abs(E.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(E.length);case"CIMGeometricEffectJog":return Math.abs(.5*E.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,Q.NA)(E.offsetX)),Math.abs((0,Q.NA)(E.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(E.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(E.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(E.fromWidth),Math.abs(E.toWidth));case"CIMGeometricEffectWave":return Math.abs(E.amplitude)}}function U(E){if(!E)return 0;let l=0;for(const p of E)l+=B(p);return l}class K{getSymbolInflateSize(l,p,g,x,w){return l||(l=[0,0,0,0]),p?this._getInflateSize(l,p,g,x,w):l}static SafeSize(l){const p=Math.max(Math.abs(l[0]),Math.abs(l[2])),g=Math.max(Math.abs(l[1]),Math.abs(l[3]));return Math.sqrt(p*p+g*g)}_vectorMarkerBounds(l,p,g,x){let w=!0;const P=(0,v.Ue)();if(p&&p.markerGraphics)for(const I of p.markerGraphics){const C=[0,0,0,0];I.geometry&&((0,j.$P)(P,I.geometry),C[0]=0,C[1]=0,C[2]=0,C[3]=0,this.getSymbolInflateSize(C,I.symbol,g,0,x),P[0]+=C[0],P[1]+=C[1],P[2]+=C[2],P[3]+=C[3],w?(l[0]=P[0],l[1]=P[1],l[2]=P[2],l[3]=P[3],w=!1):(l[0]=Math.min(l[0],P[0]),l[1]=Math.min(l[1],P[1]),l[2]=Math.max(l[2],P[2]),l[3]=Math.max(l[3],P[3])))}return l}_getInflateSize(l,p,g,x,w){if(function ht(E){return void 0!==E.symbolLayers}(p)){const P=this._getLayersInflateSize(l,p.symbolLayers,g,x,w),I=U(p.effects);return I>0&&(P[0]-=I,P[1]-=I,P[2]+=I,P[3]+=I),P}return this._getTextInflatedSize(l,p,w)}_getLayersInflateSize(l,p,g,x,w){let P=!0;if(!p)return l;for(const I of p){if(!I)continue;let C=[0,0,0,0];switch(I.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const Y=I;let q=Y.width;q/="Square"===Y.capStyle||"Miter"===Y.joinStyle?1.4142135623730951:2,C[0]=-q,C[1]=-q,C[2]=q,C[3]=q;break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const Y=I;if("CIMVectorMarker"===I.type){const it=I;if(C=this._vectorMarkerBounds(C,it,g,w),it.frame){const _t=(it.frame.xmin+it.frame.xmax)/2,St=(it.frame.ymin+it.frame.ymax)/2;C[0]-=_t,C[1]-=St,C[2]-=_t,C[3]-=St;const yt=it.size/(it.frame.ymax-it.frame.ymin);C[0]*=yt,C[1]*=yt,C[2]*=yt,C[3]*=yt}}else if("CIMPictureMarker"===I.type){const it=I,_t=g.getResource(it.url);let St=1;(0,xt.pC)(_t)&&_t.height&&(St=_t.width/_t.height);const yt=Y.size/2,Rt=Y.size*St*it.scaleX/2;C=[-Rt,-yt,Rt,yt]}else{const it=Y.size/2;C=[-it,-it,it,it]}if(Y.anchorPoint){let it,_t;"Absolute"===Y.anchorPointUnits?(it=Y.anchorPoint.x,_t=Y.anchorPoint.y):(it=Y.anchorPoint.x*(C[2]-C[0]),_t=Y.anchorPoint.y*(C[3]-C[1])),C[0]-=it,C[1]-=_t,C[2]-=it,C[3]-=_t}let q=(0,Q.NA)(Y.rotation);if(Y.rotateClockwise&&(q=-q),x&&(q-=x),q){const it=pt*q,_t=Math.cos(it),St=Math.sin(it),yt=(0,v.Ue)([lt.B1,lt.B1,-lt.B1,-lt.B1]);(0,v.Ho)(yt,[C[0]*_t-C[1]*St,C[0]*St+C[1]*_t]),(0,v.Ho)(yt,[C[0]*_t-C[3]*St,C[0]*St+C[3]*_t]),(0,v.Ho)(yt,[C[2]*_t-C[1]*St,C[2]*St+C[1]*_t]),(0,v.Ho)(yt,[C[2]*_t-C[3]*St,C[2]*St+C[3]*_t]),C=yt}let gt=(0,Q.NA)(Y.offsetX),at=(0,Q.NA)(Y.offsetY);if(x){const it=pt*x,_t=Math.cos(it),St=Math.sin(it),yt=gt*St+at*_t;gt=gt*_t-at*St,at=yt}C[0]+=gt,C[1]+=at,C[2]+=gt,C[3]+=at;const dt=L(Y.markerPlacement);dt>0&&(C[0]-=dt,C[1]-=dt,C[2]+=dt,C[3]+=dt);break}}const X=U(I.effects);X>0&&(C[0]-=X,C[1]-=X,C[2]+=X,C[3]+=X),P?(l[0]=C[0],l[1]=C[1],l[2]=C[2],l[3]=C[3],P=!1):(l[0]=Math.min(l[0],C[0]),l[1]=Math.min(l[1],C[1]),l[2]=Math.max(l[2],C[2]),l[3]=Math.max(l[3],C[3]))}return l}_getTextInflatedSize(l,p,g){var x,w;const P=null!=(x=p.height)?x:10;if(l[0]=-P/2,l[1]=-P/2,l[2]=P/2,l[3]=P/2,!g)return l;const I=g.get(p);if(!I)return l;const{text:C,mosaicItem:X}=I;if(!X||0===X.glyphMosaicItems.length)return l;const Y=(0,st.et)(p.lineGapType,null!=(w=p.lineGap)?w:0,P),q=(0,z.E)(C)[1],at=(0,kt.Nr)(X.glyphMosaicItems,q,{scale:P/ct.Ex,angle:(0,Q.NA)(p.angle),xOffset:(0,Q.NA)(p.offsetX),yOffset:(0,Q.NA)(p.offsetY),hAlign:(0,st.x1)(p.horizontalAlignment),vAlign:(0,st.g)(p.verticalAlignment),maxLineWidth:512,lineHeight:ct.xm*Math.max(.25,Math.min(Y||1,4)),decoration:p.font.decoration||"none",isCIM:!0}).boundsT;return l[0]=at.x-at.halfWidth,l[1]=-at.y-at.halfHeight,l[2]=at.x+at.halfWidth,l[3]=-at.y+at.halfHeight,l}}class O{static getEnvelope(l,p){const g=new st.uQ(p);if(Array.isArray(l)){let x;for(const w of l)x?x.union(ut(g,w)):x=ut(g,w);return x}return ut(g,l)}static getTextureAnchor(l,p){const g=this.getEnvelope(l,p);if(!g)return[0,0,0];const I=g.height*F+2;return[(g.x+.5*g.width)*F/(g.width*F+2),-(g.y+.5*g.height)*F/I,I]}static rasterize(l,p,g,x,w=!0){const P=g||this.getEnvelope(p,x);if(!P)return[null,0,0,0,0];const I=(P.x+.5*P.width)*F,C=(P.y+.5*P.height)*F;l.width=P.width*F,l.height=P.height*F,g||(l.width+=2,l.height+=2);const X=l.getContext("2d"),Y=st.zA.createScale(F,-F);Y.translate(.5*l.width-I,.5*l.height+C);const q=new st.cD(X,x,Y);switch(p.type){case"CIMPointSymbol":q.drawSymbol(p,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const dt=new $.u;q.drawMarker(p,dt);break}}const gt=X.getImageData(0,0,l.width,l.height),at=new Uint8Array(gt.data);if(w){let dt;for(let it=0;it<at.length;it+=4)dt=at[it+3]/255,at[it]=at[it]*dt,at[it+1]=at[it+1]*dt,at[it+2]=at[it+2]*dt}return[at,l.width,l.height,-I/l.width,-C/l.height]}static fromTextSymbol(l){const{angle:p,color:g,font:x,haloColor:w,haloSize:P,horizontalAlignment:I,kerning:C,text:X,verticalAlignment:Y,xoffset:q,yoffset:gt}=l;let at,dt,it,_t,St;x&&(at=x.family,dt=x.style,it=x.weight,_t=x.size,St=x.decoration);let yt=!1;return X&&(yt=(0,z.E)(X)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:p,blockProgression:2,depth3D:1,extrapolateBaselines:!0,fontEffects:0,fontEncoding:1,fontFamilyName:at||"Arial",fontStyleName:N(dt,it),fontType:0,haloSize:P,height:_t,hinting:1,horizontalAlignment:b(null!=I?I:"center"),kerning:C,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,Q.NA)(q),offsetY:(0,Q.NA)(gt),strikethrough:"line-through"===St,underline:"underline"===St,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:S(g)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:S(w)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:yt?1:0,verticalAlignment:W(null!=Y?Y:"baseline"),verticalGlyphOrientation:0,wordSpacing:100,billboardMode3D:2},textString:X}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(l){const{height:p,outline:g,width:x,xoffset:w,xscale:P,yoffset:I,yscale:C}=l,X=[],Y={type:"CIMPolygonSymbol",symbolLayers:X};if(g){const{cap:it,join:_t,miterLimit:St,width:yt}=g;X.push({type:"CIMSolidStroke",color:S(g.color),capStyle:M(it),joinStyle:y(_t),miterLimit:St,width:yt})}let q=l.url;"esriPFS"===l.type&&l.imageData&&(q=l.imageData);const gt="angle"in l?l.angle:0;return X.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:"Picture",tintColor:null,url:q,height:p*(C||1),width:x*(P||1),offsetX:(0,Q.NA)(w),offsetY:(0,Q.NA)(I),rotation:(0,Q.NA)(-gt),colorSubstitutions:null}),Y}static fromSimpleFillSymbol(l){const{color:p,style:g,outline:x}=l,w=[],P={type:"CIMPolygonSymbol",symbolLayers:w};let I=null;if(x){const{cap:C,join:X,style:Y}=x;"solid"!==Y&&"none"!==Y&&"esriSLSSolid"!==Y&&"esriSLSNull"!==Y&&(I=[{type:"CIMGeometricEffectDashes",dashTemplate:et(Y,C),lineDashEnding:"NoConstraint",scaleDash:!0}]),w.push({type:"CIMSolidStroke",color:S(x.color),capStyle:M(C),joinStyle:y(X),miterLimit:x.miterLimit,width:x.width,effects:I})}if(g&&"solid"!==g&&"none"!==g&&"esriSFSSolid"!==g&&"esriSFSNull"!==g){const C={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:S(p),capStyle:"Butt",joinStyle:"Miter",width:.75}]};let X=0;const Y=(0,mt.fp)(Math.ceil(window.devicePixelRatio)),q=tt(g)?8*Y:10*Y;switch(g){case"vertical":case"esriSFSVertical":X=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":X=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":X=45;break;case"cross":case"esriSFSCross":X=0}w.push({type:"CIMHatchFill",lineSymbol:C,offsetX:0,offsetY:0,rotation:X,separation:q}),"cross"===g||"esriSFSCross"===g?w.push({type:"CIMHatchFill",lineSymbol:(0,nt.d9)(C),offsetX:0,offsetY:0,rotation:90,separation:q}):"diagonal-cross"!==g&&"esriSFSDiagonalCross"!==g||w.push({type:"CIMHatchFill",lineSymbol:(0,nt.d9)(C),offsetX:0,offsetY:0,rotation:45,separation:q})}else!g||"solid"!==g&&"esriSFSSolid"!==g||w.push({type:"CIMSolidFill",enable:!0,color:S(p)});return P}static fromSimpleLineSymbol(l){const{cap:p,color:g,join:x,marker:w,miterLimit:P,style:I,width:C}=l;let X=null;"solid"!==I&&"none"!==I&&"esriSLSSolid"!==I&&"esriSLSNull"!==I&&(X=[{type:"CIMGeometricEffectDashes",dashTemplate:et(I,p),lineDashEnding:"NoConstraint",scaleDash:!0}]);const Y=[];if(w){let q;switch(w.placement){case"begin-end":q="Both";break;case"begin":q="JustBegin";break;case"end":q="JustEnd";break;default:q="None"}const gt=O.fromSimpleMarker(w,C,g).symbolLayers[0];gt.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:q,offsetAlongLine:0},Y.push(gt)}return"none"!==I&&"esriSLSNull"!==I&&Y.push({type:"CIMSolidStroke",color:S(g),capStyle:M(p),joinStyle:y(x),miterLimit:P,width:C,effects:X}),{type:"CIMLineSymbol",symbolLayers:Y}}static fromPictureMarker(l){const{angle:p,height:g,width:x,xoffset:w,yoffset:P}=l;let I=l.url;return"esriPMS"===l.type&&l.imageData&&(I=l.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:"Picture",tintColor:null,url:I,size:g,width:x,offsetX:(0,Q.NA)(w),offsetY:(0,Q.NA)(P),rotation:(0,Q.NA)(-p)}]}}static fromSimpleMarker(l,p,g){var x;const{style:w}=l,P=null!=(x=l.color)?x:g;if("path"===w){const Y=[];if("outline"in l&&l.outline){const at=l.outline;Y.push({type:"CIMSolidStroke",enable:!0,width:(0,k.F2)(Math.round((0,k.Wz)(at.width))),color:S(at.color)})}Y.push({type:"CIMSolidFill",enable:!0,color:S(P),path:l.path});const[q,gt]=wt("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,Q.NA)(-l.angle),size:(0,Q.NA)(l.size||6),offsetX:(0,Q.NA)(l.xoffset),offsetY:(0,Q.NA)(l.yoffset),frame:q,markerGraphics:[{type:"CIMMarkerGraphic",geometry:gt,symbol:{type:"CIMPolygonSymbol",symbolLayers:Y}}]}]}}const[I,C]=wt(w);let X;if(C&&I){const Y=[];if("outline"in l&&l.outline){const gt=l.outline;Y.push({type:"CIMSolidStroke",enable:!0,width:(0,k.F2)(Math.round((0,k.Wz)(gt.width))),color:S(gt.color)})}else!p||"line-marker"!==l.type||"cross"!==l.style&&"x"!==l.style||Y.push({type:"CIMSolidStroke",enable:!0,width:p,color:S(P)});Y.push({type:"CIMSolidFill",enable:!0,color:S(P)});const q={type:"CIMPolygonSymbol",symbolLayers:Y};X={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,Q.NA)(-l.angle),size:(0,Q.NA)(l.size||6*p),offsetX:(0,Q.NA)(l.xoffset),offsetY:(0,Q.NA)(l.yoffset),frame:I,markerGraphics:[{type:"CIMMarkerGraphic",geometry:C,symbol:q}]}]}}return X}static fromCIMHatchFill(l){var p;const g=null!=(p=l.separation)?p:4,x=g/2;let P=this._getLineSymbolPeriod(l.lineSymbol)||4;for(;P<4;)P*=2;const I=P/2;return{type:"CIMVectorMarker",frame:{xmin:-I,xmax:I,ymin:-x,ymax:x},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-I,0],[I,0]]]},symbol:l.lineSymbol}],size:g}}static _getLineSymbolPeriod(l){if(l){const p=this._getEffectsRepeat(l.effects);if(p)return p;if(l.symbolLayers)for(const g of l.symbolLayers){const x=this._getEffectsRepeat(g.effects);if(x)return x;if(g){const w=this._getPlacementRepeat(g.markerPlacement);if(w)return w}}}return 0}static _getEffectsRepeat(l){if(l)for(const p of l)if(p)switch(p.type){case"CIMGeometricEffectDashes":{const g=p.dashTemplate;if(g&&g.length){let x=0;for(const w of g)x+=w;return 1&g.length&&(x*=2),x}break}case"CIMGeometricEffectWave":return p.period;default:Tt.error(`unsupported geometric effect type ${p.type}`)}return 0}static _getPlacementRepeat(l){if(l)switch(l.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const p=l.placementTemplate;if(p&&p.length){let g=0;for(const x of p)g+=x;return 1&p.length&&(g*=2),g}break}}return 0}static fromCIMInsidePolygon(l){const p=l.markerPlacement,g=Gt({type:l.type},l);let x,w,P,I;return g.markerPlacement=null,g.anchorPoint=null,!0===p.shiftOddRows?(w=p.stepX/2,P=p.stepY,I=2*p.stepY,x=[{x:-w,y:0},{x:w,y:0},{x:0,y:P},{x:0,y:-P}].map(C=>({type:"CIMMarkerGraphic",geometry:C,symbol:{type:"CIMPointSymbol",symbolLayers:[g]}}))):(w=p.stepX/2,P=p.stepY/2,I=p.stepY,x=[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMPointSymbol",symbolLayers:[g]}}]),{type:"CIMVectorMarker",frame:{xmin:-w,xmax:w,ymin:-P,ymax:P},markerGraphics:x,size:I}}static getFillColor(l){if(!l)return null;switch(l.type){case"CIMPolygonSymbol":if(l.symbolLayers)for(const p of l.symbolLayers){const g=O.getFillColor(p);if(null!=g)return g}break;case"CIMTextSymbol":return O.getFillColor(l.symbol);case"CIMSolidFill":return l.color}}static getStrokeColor(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const p of l.symbolLayers){const g=O.getStrokeColor(p);if(void 0!==g)return g}break;case"CIMTextSymbol":return O.getStrokeColor(l.symbol);case"CIMSolidStroke":return l.color}}static getStrokeWidth(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const p of l.symbolLayers){const g=O.getStrokeWidth(p);if(void 0!==g)return g}break;case"CIMTextSymbol":return O.getStrokeWidth(l.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return l.width}}static getSize(l){if(l)switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{let p=0;if(l.symbolLayers)for(const g of l.symbolLayers){const x=O.getSize(g);x>p&&(p=x)}return p}case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":return l.width;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":return l.size}}static getMarkerScaleRatio(l){return l&&"CIMVectorMarker"===l.type&&!1!==l.scaleSymbolsProportionally&&l.frame?l.size/(l.frame.ymax-l.frame.ymin):1}}class n{static rasterizeSimpleFill(l,p,g){"solid"!==p&&"none"!==p&&"esriSFSSolid"!==p&&"esriSFSNull"!==p||console.error("Unexpected: style does not require rasterization");const x=(0,mt.fp)(Math.ceil(g)),w=tt(p)?8*x:16*x,P=2*x;l.width=w,l.height=w;const I=l.getContext("2d");I.strokeStyle="#FFFFFF",I.lineWidth=x,I.beginPath(),"vertical"!==p&&"cross"!==p&&"esriSFSCross"!==p&&"esriSFSVertical"!==p||(I.moveTo(w/2,-P),I.lineTo(w/2,w+P)),"horizontal"!==p&&"cross"!==p&&"esriSFSCross"!==p&&"esriSFSHorizontal"!==p||(I.moveTo(-P,w/2),I.lineTo(w+P,w/2)),"forward-diagonal"!==p&&"diagonal-cross"!==p&&"esriSFSDiagonalCross"!==p&&"esriSFSForwardDiagonal"!==p||(I.moveTo(-P,-P),I.lineTo(w+P,w+P),I.moveTo(w-P,-P),I.lineTo(w+P,P),I.moveTo(-P,w-P),I.lineTo(P,w+P)),"backward-diagonal"!==p&&"diagonal-cross"!==p&&"esriSFSBackwardDiagonal"!==p&&"esriSFSDiagonalCross"!==p||(I.moveTo(w+P,-P),I.lineTo(-P,w+P),I.moveTo(P,-P),I.lineTo(-P,P),I.moveTo(w+P,w-P),I.lineTo(w-P,w+P)),I.stroke();const C=I.getImageData(0,0,l.width,l.height),X=new Uint8Array(C.data);let Y;for(let q=0;q<X.length;q+=4)Y=X[q+3]/255,X[q]=X[q]*Y,X[q+1]=X[q+1]*Y,X[q+2]=X[q+2]*Y;return[X,l.width,l.height]}static rasterizeSimpleLine(l,p){return this.rasterizeDash(l,p)}static rasterizeDash(l,p){const g="Butt"===p,x="Square"===p,w=!g&&!x;l.length%2==1&&(l=[...l,...l]);const P=15.5;let C=0;for(const yt of l)C+=yt;const X=Math.round(C*P),Y=new Float32Array(31*X),q=7.75;let gt=0,at=0,dt=.5,it=!0;for(const yt of l){for(gt=at,at+=yt*P;dt<=at;){let Rt=.5;for(;Rt<31;){const Ot=(Rt-.5)*X+dt-.5,Dt=w?(Rt-P)*(Rt-P):Math.abs(Rt-P);Y[Ot]=it?g?Math.max(Math.max(gt+q-dt,Dt),Math.max(dt-at+q,Dt)):Dt:w?Math.min((dt-gt)*(dt-gt)+Dt,(dt-at)*(dt-at)+Dt):x?Math.min(Math.max(dt-gt,Dt),Math.max(at-dt,Dt)):Math.min(Math.max(dt-gt+q,Dt),Math.max(at+q-dt,Dt)),Rt++}dt++}it=!it}const _t=Y.length,St=new Uint8Array(4*_t);for(let yt=0;yt<_t;++yt){const Rt=(w?Math.sqrt(Y[yt]):Y[yt])/P;(0,J.I)(Rt,St,4*yt)}return[St,X,31]}}class _{static findApplicableOverrides(l,p,g){if(p){if(l.primitiveName){let x=!1;for(const w of g)if(w.primitiveName===l.primitiveName){x=!0;break}if(!x)for(const w of p)w.primitiveName===l.primitiveName&&g.push(w)}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const x of l.effects)_.findApplicableOverrides(x,p,g);if(l.symbolLayers)for(const x of l.symbolLayers)_.findApplicableOverrides(x,p,g);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(l.effects)for(const x of l.effects)_.findApplicableOverrides(x,p,g);if(l.markerPlacement&&_.findApplicableOverrides(l.markerPlacement,p,g),"CIMVectorMarker"===l.type){if(l.markerGraphics)for(const x of l.markerGraphics)_.findApplicableOverrides(x,p,g),_.findApplicableOverrides(x.symbol,p,g)}else"CIMCharacterMarker"===l.type?_.findApplicableOverrides(l.symbol,p,g):"CIMHatchFill"===l.type&&_.findApplicableOverrides(l.lineSymbol,p,g)}}}static applyOverrides(l,p,g,x){if(!p)return;const w=P=>P&&P.charAt(0).toLowerCase()+P.substr(1);if(l.primitiveName)for(const P of p)if(P.primitiveName===l.primitiveName){const I=w(P.propertyName);if(x&&x.push({cim:l,nocapPropertyName:I,value:l[I]}),P.expression&&(P.value=_.toValue(P.propertyName,P.expression)),g){let C=!1;for(const X of g)X.primitiveName===l.primitiveName&&(C=!0);C||g.push(P)}l[I]=P.value}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const P of l.effects)_.applyOverrides(P,p,g,x);if(l.symbolLayers)for(const P of l.symbolLayers)_.applyOverrides(P,p,g,x);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(l.effects)for(const P of l.effects)_.applyOverrides(P,p,g,x);if("CIMVectorMarker"===l.type&&l.markerGraphics)for(const P of l.markerGraphics)_.applyOverrides(P,p,g,x),_.applyOverrides(P.symbol,p,g,x)}}static restoreOverrides(l){for(const p of l)p.cim[p.nocapPropertyName]=p.value}static buildOverrideKey(l){let p="";for(const g of l)void 0!==g.value&&(p+=`${g.primitiveName}${g.propertyName}${JSON.stringify(g.value)}`);return p}static toValue(l,p){if("DashTemplate"===l)return p.split(" ").map(g=>Number(g));if("Color"===l){const g=new V.Z(p).toRgba();return g[3]*=255,g}return p}}const M=E=>{if(!E)return"Butt";switch(E){case"butt":return"Butt";case"square":return"Square";case"round":return"Round"}},y=E=>{if(!E)return"Miter";switch(E){case"miter":return"Miter";case"round":return"Round";case"bevel":return"Bevel"}},b=E=>{if(!E)return"Center";switch(E){case"left":return"Left";case"right":return"Right";case"center":return"Center";case"justify":return"Justify"}},W=E=>{if(!E)return"Center";switch(E){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},S=E=>{if(!E)return[0,0,0,0];const{r:l,g:p,b:g,a:x}=E;return[l,p,g,255*x]},N=(E,l)=>{const p=rt(l),g=ot(E);return p&&g?`${p}-${g}`:`${p}${g}`},rt=E=>{if(!E)return"";switch(E.toLowerCase()){case"bold":case"bolder":return"bold"}return""},ot=E=>{if(!E)return"";switch(E.toLowerCase()){case"italic":case"oblique":return"italic"}return""},et=(E,l)=>{const p="butt"===l;switch(E){case"dash":case"esriSLSDash":return p?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return p?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return p?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return p?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return p?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return p?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return p?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return p?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return p?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return p?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return Tt.error("Unexpected: style does not require rasterization"),[0,0];default:return Tt.error(`Tried to rasterize SLS, but found an unexpected style: ${E}!`),[0,0]}},wt=E=>{let g,x;const w=E;if("circle"===w||"esriSMSCircle"===w){let I=Math.acos(.995),C=Math.ceil(bt/I/4);0===C&&(C=1),I=It/C,C*=4;const X=[];X.push([50,0]);for(let Y=1;Y<C;Y++)X.push([50*Math.cos(Y*I),-50*Math.sin(Y*I)]);X.push([50,0]),g={rings:[X]},x={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===w||"esriSMSCross"===w)g={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},x={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===w||"esriSMSDiamond"===w)g={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},x={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===w||"esriSMSSquare"===w)g={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},x={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===w||"esriSMSX"===w)g={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},x={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===w||"esriSMSTriangle"===w){const P=57.735026918962575,I=-P,C=2/3*100,X=C-100;g={rings:[[[I,X],[0,C],[P,X],[I,X]]]},x={xmin:I,ymin:X,xmax:P,ymax:C}}else"arrow"===w&&(g={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},x={xmin:-50,ymin:-50,xmax:50,ymax:50});return[x,g]},tt=E=>"vertical"===E||"horizontal"===E||"cross"===E||"esriSFSCross"===E||"esriSFSVertical"===E||"esriSFSHorizontal"===E},31375:(Et,ft,R)=>{R.d(ft,{Z:()=>V});class V{constructor(J=0,nt=0,Mt=0,mt=0){this.x=J,this.y=nt,this.width=Mt,this.height=mt}get isEmpty(){return this.width<=0||this.height<=0}union(J){this.x=Math.min(this.x,J.x),this.y=Math.min(this.y,J.y),this.width=Math.max(this.width,J.width),this.height=Math.max(this.height,J.height)}}},68937:(Et,ft,R)=>{R.d(ft,{d:()=>nt});var V=R(23841);class nt{constructor(){}rasterizeText(k,v){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const j=this._textRasterizationCanvas,$=j.getContext("2d");this.setFontProperties($,v),this.parameters=v,this.textLines=k.split(/\r?\n/),this.lineHeight=this.computeLineHeight();const st=this.computeTextWidth($,v),{decoration:Q,weight:lt}=v.font;this.lineThroughWidthOffset=Q&&"line-through"===Q?.1*this.lineHeight:0;const ct=this.lineHeight*this.textLines.length;j.width=st+2*this.lineThroughWidthOffset,j.height=ct,this.renderedLineHeight=Math.round(this.lineHeight*v.pixelRatio),this.renderedHaloSize=v.halo.size*v.pixelRatio,this.renderedWidth=st*v.pixelRatio,this.renderedHeight=ct*v.pixelRatio,this.lineThroughWidthOffset*=v.pixelRatio,this.fillStyle=function J(xt){return`rgba(${xt.slice(0,3).toString()},${xt[3]})`}(v.color),this.haloStyle=function z(xt){return`rgb(${xt.slice(0,3).toString()})`}(v.halo.color);const kt=this.renderedLineHeight,bt=this.renderedHaloSize;this.setFontProperties($,v);const It=function Mt(xt,k){return"center"===xt?.5*k:"right"===xt?k:0}($.textAlign,this.renderedWidth)+bt,Lt=bt;let F=this.lineThroughWidthOffset,pt=0;bt>0&&this.renderHalo($,It,Lt,F,pt,v),pt+=Lt,F+=It;for(const B of this.textLines)$.globalCompositeOperation="destination-out",$.fillStyle="rgb(0, 0, 0)",$.fillText(B,F,pt),$.globalCompositeOperation="source-over",$.fillStyle=this.fillStyle,$.fillText(B,F,pt),Q&&"none"!==Q&&this.renderDecoration($,F,pt,Q,lt),pt+=kt;const Tt=this.renderedWidth+2*this.lineThroughWidthOffset,zt=this.renderedHeight,ut=$.getImageData(0,0,Tt,zt),L=new Uint8Array(ut.data);if(v.premultiplyColors){let B;for(let U=0;U<L.length;U+=4)B=L[U+3]/255,L[U]=L[U]*B,L[U+1]=L[U+1]*B,L[U+2]=L[U+2]*B}return{size:[Tt,zt],image:new Uint32Array(L.buffer),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0}}renderHalo(k,v,j,$,st,Q){const lt=this.renderedWidth,ct=this.renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=lt,this._haloRasterizationCanvas.height=ct;const kt=this._haloRasterizationCanvas,bt=kt.getContext("2d");bt.clearRect(0,0,lt,ct),this.setFontProperties(bt,Q);const{decoration:It,weight:Lt}=Q.font;bt.fillStyle=this.haloStyle,bt.strokeStyle=this.haloStyle;const D=this.renderedHaloSize<3;bt.lineJoin=D?"miter":"round",D?this.renderHaloEmulated(bt,v,j,It,Lt):this.renderHaloNative(bt,v,j,It,Lt),k.globalAlpha=this.parameters.halo.color[3],k.drawImage(kt,0,0,lt,ct,$,st,lt,ct),k.globalAlpha=1}renderHaloEmulated(k,v,j,$,st){const Q=this.renderedLineHeight,lt=this.renderedHaloSize;for(const ct of this.textLines){for(const[kt,bt]of mt)k.fillText(ct,v+lt*kt,j+lt*bt);$&&"none"!==$&&this.renderDecoration(k,v,j,$,st),j+=Q}}renderHaloNative(k,v,j,$,st){const Q=this.renderedLineHeight,lt=this.renderedHaloSize;for(const ct of this.textLines){const kt=2*lt,bt=5,It=.1;for(let Lt=0;Lt<bt;Lt++)k.lineWidth=(1-(bt-1)*It+Lt*It)*kt,k.strokeText(ct,v,j),$&&"none"!==$&&this.renderDecoration(k,v,j,$,st);j+=Q}}setFontProperties(k,v){const j=v.font,$=`${j.style} ${j.weight} ${(0,V.F2)(v.size*v.pixelRatio)}px ${j.family}, sans-serif`;let st;switch(k.font=$,k.textBaseline="top",v.horizontalAlignment){case"left":default:st="left";break;case"right":st="right";break;case"center":st="center"}k.textAlign=st}computeTextSize(k,v){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const j=this._textRasterizationCanvas,$=j.getContext("2d");this.setFontProperties($,v),this.parameters=v,this.textLines=k.split(/\r?\n/),this.lineHeight=this.computeLineHeight();const st=this.computeTextWidth($,v),Q=this.lineHeight*this.textLines.length;return j.width=st,j.height=Q,[st*v.pixelRatio,Q*v.pixelRatio]}computeTextWidth(k,v){let j=0;for(const st of this.textLines)j=Math.max(j,k.measureText(st).width);const $=v.font;return("italic"===$.style||"oblique"===$.style||"string"==typeof $.weight&&("bold"===$.weight||"bolder"===$.weight)||"number"==typeof $.weight&&$.weight>600)&&(j+=.3*k.measureText("w").width),j+=2*this.parameters.halo.size,Math.round(j)}computeLineHeight(){let k=1.275*this.parameters.size;const v=this.parameters.font.decoration;return v&&"underline"===v&&(k*=1.3),Math.round(k+2*this.parameters.halo.size)}renderDecoration(k,v,j,$,st){const Q=.9*this.lineHeight,lt="bold"===st?.06:"bolder"===st?.09:.04;switch(k.textAlign){case"center":v-=this.renderedWidth/2;break;case"right":v-=this.renderedWidth}const ct=k.textBaseline;if("underline"===$)switch(ct){case"top":j+=Q;break;case"middle":j+=Q/2}else if("line-through"===$)switch(ct){case"top":j+=Q/1.5;break;case"middle":j+=Q/3}k.save(),k.beginPath(),k.strokeStyle=k.fillStyle,k.lineWidth=Math.ceil(Q*lt),k.moveTo(v-this.lineThroughWidthOffset,j),k.lineTo(v+this.renderedWidth+2*this.lineThroughWidthOffset,j),k.stroke(),k.restore()}}const mt=[];for(let k=0;k<360;k+=22.5)mt.push([Math.cos(Math.PI*k/180),Math.sin(Math.PI*k/180)])},61261:(Et,ft,R)=>{var V,z,v;function J(v){switch(v){case"left":return V.Left;case"right":return V.Right;case"center":case"justify":return V.Center}}function nt(v){switch(v){case"top":return z.Top;case"middle":return z.Center;case"baseline":return z.Baseline;case"bottom":return z.Bottom}}function Mt(v){switch(v){case"above-left":case"esriServerPointLabelPlacementAboveLeft":return[V.Right,z.Bottom];case"above-center":case"above-along":case"esriServerPointLabelPlacementAboveCenter":case"esriServerLinePlacementAboveAlong":return[V.Center,z.Bottom];case"above-right":case"esriServerPointLabelPlacementAboveRight":return[V.Left,z.Bottom];case"center-left":case"esriServerPointLabelPlacementCenterLeft":return[V.Right,z.Center];case"center-center":case"center-along":case"esriServerPointLabelPlacementCenterCenter":case"esriServerLinePlacementCenterAlong":case"always-horizontal":case"esriServerPolygonPlacementAlwaysHorizontal":return[V.Center,z.Center];case"center-right":case"esriServerPointLabelPlacementCenterRight":return[V.Left,z.Center];case"below-left":case"esriServerPointLabelPlacementBelowLeft":return[V.Right,z.Top];case"below-center":case"below-along":case"esriServerPointLabelPlacementBelowCenter":case"esriServerLinePlacementBelowAlong":return[V.Center,z.Top];case"below-right":case"esriServerPointLabelPlacementBelowRight":return[V.Left,z.Top];default:return console.debug(`Found invalid placement type ${v}`),[V.Center,z.Center]}}function mt(v){switch(v){case V.Right:return-1;case V.Center:return 0;case V.Left:return 1;default:return console.debug(`Found invalid horizontal alignment ${v}`),0}}function xt(v){switch(v){case z.Top:return 1;case z.Center:return 0;case z.Bottom:case z.Baseline:return-1;default:return console.debug(`Found invalid vertical alignment ${v}`),0}}function k(v){switch(v){case"left":return V.Left;case"right":return V.Right;case"center":case"justify":return V.Center}}R.d(ft,{M7:()=>V,TR:()=>z,qv:()=>Mt,Hd:()=>k,kH:()=>J,g:()=>mt,b7:()=>nt,tf:()=>xt}),(v=V||(V={}))[v.Left=-1]="Left",v[v.Center=0]="Center",v[v.Right=1]="Right",function(v){v[v.Top=1]="Top",v[v.Center=0]="Center",v[v.Bottom=-1]="Bottom",v[v.Baseline=2]="Baseline"}(z||(z={}))},25797:(Et,ft,R)=>{R.d(ft,{Nr:()=>zt});var V=R(31478),z=R(12225),J=R(67831),nt=R(9545),Mt=R(61261),mt=R(5254),xt=R(84439);class k{constructor(L,B,U,K){this.center=(0,nt.f)(L,B),this.centerT=(0,nt.c)(),this.halfWidth=U/2,this.halfHeight=K/2,this.width=U,this.height=K}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(L){this.center[0]=L}set y(L){this.center[1]=L}clone(){return new k(this.x,this.y,this.width,this.height)}serialize(L){return L.writeF32(this.center[0]),L.writeF32(this.center[1]),L.push(this.width),L.push(this.height),L}findCollisionDelta(L,B=4){const U=Math.abs(L.centerT[0]-this.centerT[0]),K=Math.abs(L.centerT[1]-this.centerT[1]),_=Math.min((L.halfWidth+this.halfWidth+B)/U,(L.halfHeight+this.halfHeight+B)/K);return Math.log2(_)}extend(L){const B=Math.min(this.xmin,L.xmin),U=Math.min(this.ymin,L.ymin),K=Math.max(this.xmax,L.xmax)-B,O=Math.max(this.ymax,L.ymax)-U,n=B+K/2,_=U+O/2;this.width=K,this.height=O,this.halfWidth=K/2,this.halfHeight=O/2,this.x=n,this.y=_}static deserialize(L){const B=L.readF32(),U=L.readF32(),K=L.readInt32(),O=L.readInt32();return new k(B,U,K,O)}}const ct=Math.PI/180;class kt{constructor(L,B,U,K){this._rotationT=(0,z.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const O=U.rect,n=new Float32Array(8);B*=K;const _=U.code?O.width*K:U.metrics.width,M=U.code?O.height*K:U.metrics.height;n[0]=L*=K,n[1]=B,n[2]=L+_,n[3]=B,n[4]=L,n[5]=B+M,n[6]=L+_,n[7]=B+M,this._data=n,this._setTextureCoords(O),this._scale=K,this._mosaic=U,this.x=L,this.y=B,this.maxOffset=Math.max(L+_,B+M)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(L){this._angle=L,(0,V.i)(this._rotationT),(0,V.r)(this._rotationT,this._rotationT,-L),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:L,width:B}=this._mosaic.metrics,U=B*this._scale,K=Math.abs(L)*this._scale,O=new Float32Array(8);O[0]=this.x,O[1]=this.y,O[2]=this.x+U,O[3]=this.y,O[4]=this.x,O[5]=this.y+K,O[6]=this.x+U,O[7]=this.y+K;const n=(0,V.m)((0,z.c)(),this._rotationT,this._T);(0,z.t)(O,O,n);let _=1/0,M=1/0,y=0,b=0;for(let ot=0;ot<4;ot++){const et=O[2*ot],ht=O[2*ot+1];_=Math.min(_,et),M=Math.min(M,ht),y=Math.max(y,et),b=Math.max(b,ht)}const W=y-_,S=b-M;this._bounds=new k(_+W/2,M+S/2,W,S)}return this._bounds}setTransform(L){this._T=L,this._offsets=null}_setOffsets(L){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const B=this._offsets,U=new Float32Array(8),K=(0,V.m)((0,z.c)(),this._rotationT,this._T);(0,z.t)(U,L,K),B.upperLeft=(0,mt.UJ)(8*U[0],8*U[1]),B.upperRight=(0,mt.UJ)(8*U[2],8*U[3]),B.lowerLeft=(0,mt.UJ)(8*U[4],8*U[5]),B.lowerRight=(0,mt.UJ)(8*U[6],8*U[7])}_setTextureCoords({x:L,y:B,width:U,height:K}){this._texcoords={upperLeft:(0,mt.UJ)(L,B),upperRight:(0,mt.UJ)(L+U,B),lowerLeft:(0,mt.UJ)(L,B+K),lowerRight:(0,mt.UJ)(L+U,B+K)}}}const bt=(ut,L)=>({code:0,page:0,sdf:!0,rect:new xt.Z(0,0,11,8),textureBinding:L,metrics:{advance:0,height:4,width:ut,left:0,top:0}});class It{constructor(L,B,U){this._rotation=0,this._decorate(L,B,U),this.glyphs=L,this.bounds=this._createBounds(L),this.isMultiline=B.length>1,this._hasRotation=0!==U.angle,this._T=this._createGlyphTransform(this.bounds,U);for(const K of L)K.setTransform(this._T)}setRotation(L){if(0===L&&0===this._rotation)return;this._rotation=L;const B=this._T,U=(0,V.b)((0,z.c)(),L);(0,V.m)(B,U,B);for(const K of this.glyphs)K.setTransform(this._T)}_decorate(L,B,U){if(!U.decoration||"none"===U.decoration||!L.length)return;const K=U.scale,O="underline"===U.decoration?30:20,n=L[0].textureBinding;for(const _ of B)L.push(new kt(_.startX*K,_.startY*K+O*K,bt((_.width+_.glyphWidthEnd)*K,n),1))}get boundsT(){const L=this.bounds,B=(0,J.s)((0,nt.c)(),L.x,L.y);if((0,J.t)(B,B,this._T),this._hasRotation){const U=Math.max(L.width,L.height);return new k(B[0],B[1],U,U)}return new k(B[0],B[1],L.width,L.height)}_createBounds(L){let B=1/0,U=1/0,K=0,O=0;for(const M of L)B=Math.min(B,M.xTopLeft),U=Math.min(U,M.yTopLeft),K=Math.max(K,M.xTopLeft+M.width),O=Math.max(O,M.yBottomRight);const n=K-B,_=O-U;return new k(B+n/2,U+_/2,n,_)}_createGlyphTransform(L,B){const U=ct*B.angle,K=(0,z.c)(),O=(0,nt.c)();return(0,V.t)(K,K,(0,J.s)(O,B.xOffset,-B.yOffset)),B.isCIM?(0,V.r)(K,K,U):((0,V.t)(K,K,(0,J.s)(O,L.x,L.y)),(0,V.r)(K,K,U),(0,V.t)(K,K,(0,J.s)(O,-L.x,-L.y))),K}}class Lt{constructor(L,B,U,K,O,n){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(B,U)),this.end=Math.max(0,Math.max(B,U)),this.end<L.length&&(this.glyphWidthEnd=L[this.end].metrics.width),this.width=K,this.yMin=O,this.yMax=n}}const D=ut=>10===ut,F=ut=>32===ut;function zt(ut,L,B){const U=B.scale,K=new Array,O=function pt(ut,L,B){const U=new Array,O=B.maxLineWidth*(1/B.scale),n=L?ut.length-1:0,_=L?-1:ut.length,M=L?-1:1;let y=n,b=0,W=0,S=y,N=S,rt=0,ot=1/0,et=0;for(;y!==_;){const{code:wt,metrics:tt}=ut[y],E=Math.abs(tt.top);D(wt)||F(wt)||(ot=Math.min(ot,E),et=Math.max(et,E+tt.height)),D(wt)?(y!==n&&(U.push(new Lt(ut,S,y-M,b,ot,et)),ot=1/0,et=0),b=0,S=y+M,N=y+M,W=0):F(wt)?(N=y+M,W=0,rt=tt.advance,b+=tt.advance):b>O?(N!==S?(b-=rt,U.push(new Lt(ut,S,N-2*M,b-W,ot,et)),ot=1/0,et=0,S=N,b=W):(U.push(new Lt(ut,S,y-M,b,ot,et)),ot=1/0,et=0,S=y,N=y,b=0),b+=tt.advance,W+=tt.advance):(b+=tt.advance,W+=tt.advance),y+=M}const ht=new Lt(ut,S,y-M,b,ot,et);return ht.start>=0&&ht.end<ut.length&&U.push(ht),U}(ut,L,B),n=function Tt(ut,L){let B=0;for(let O=0;O<ut.length;O++){const{width:n}=ut[O];B=Math.max(n,B)}const K=ut[0].yMin;return{x:0,y:K,height:ut[ut.length-1].yMax+L.lineHeight*(ut.length-1)+("underline"===L.decoration?4:0)-K,width:B}}(O,B),{vAlign:_,hAlign:M}=B,y=_===Mt.TR.Baseline?1:0,W=(1-y)*-n.y+n.height/2*(y?0:_-1)+-26*(y?1:0);for(let S=0;S<O.length;S++){const{start:N,end:rt,width:ot}=O[S];let et=-1*(M+1)*(ot/2)-3;const ht=S*B.lineHeight+W-3;O[S].startX=et,O[S].startY=ht;for(let wt=N;wt<=rt;wt++){const tt=ut[wt];if(D(tt.code))continue;const E=new kt(et+tt.metrics.left,ht-tt.metrics.top,tt,U);et+=tt.metrics.advance,K.push(E)}}return new It(K,O,B)}}}]);