"use strict";var Gt=Object.defineProperty,St=Object.defineProperties,Dt=Object.getOwnPropertyDescriptors,Zt=Object.getOwnPropertySymbols,Et=Object.prototype.hasOwnProperty,Lt=Object.prototype.propertyIsEnumerable,Nt=(j,D,T)=>D in j?Gt(j,D,{enumerable:!0,configurable:!0,writable:!0,value:T}):j[D]=T,Rt=(j,D)=>{for(var T in D||(D={}))Et.call(D,T)&&Nt(j,T,D[T]);if(Zt)for(var T of Zt(D))Lt.call(D,T)&&Nt(j,T,D[T]);return j},Tt=(j,D)=>St(j,Dt(D));(self.webpackChunksite=self.webpackChunksite||[]).push([[6089],{7848:(j,D,T)=>{T.d(D,{ym:()=>It,RF:()=>nt,vY:()=>rt,J9:()=>Pt,U1:()=>ft,Ie:()=>Ft,G6:()=>vt});var Q=T(62208),K=T(91179);const V=(C,M,P)=>[M,P],B=(C,M,P)=>[M,P,C[2]],X=(C,M,P)=>[M,P,C[2],C[3]];function rt(C){return C?{originPosition:"upper-left"===C.originPosition?"upperLeft":"lower-left"===C.originPosition?"lowerLeft":C.originPosition,scale:C.tolerance?[C.tolerance,C.tolerance]:[1,1],translate:(0,Q.pC)(C.extent)?[C.extent.xmin,C.extent.ymax]:[0,0]}:null}function Y({scale:C,translate:M},P){return Math.round((P-M[0])/C[0])}function J({scale:C,translate:M},P){return Math.round((M[1]-P)/C[1])}function $(C,M,P){const v=[];let N,A,z,k;for(let S=0;S<P.length;S++){const L=P[S];S>0?(z=Y(C,L[0]),k=J(C,L[1]),z===N&&k===A||(v.push(M(L,z-N,k-A)),N=z,A=k)):(N=Y(C,L[0]),A=J(C,L[1]),v.push(M(L,N,A)))}return v.length>0?v:null}function w({scale:C,translate:M},P){return P*C[0]+M[0]}function O({scale:C,translate:M},P){return M[1]-P*C[1]}function et(C,M,P){const v=new Array(P.length);if(!P.length)return v;const[N,A]=C.scale;let z=w(C,P[0][0]),k=O(C,P[0][1]);v[0]=M(P[0],z,k);for(let S=1;S<P.length;S++){const L=P[S];z+=L[0]*N,k-=L[1]*A,v[S]=M(L,z,k)}return v}function W(C,M,P){const v=new Array(P.length);for(let N=0;N<P.length;N++)v[N]=et(C,M,P[N]);return v}function nt(C,M,P,v,N){return M.x=Y(C,P.x),M.y=J(C,P.y),M!==P&&(v&&(M.z=P.z),N&&(M.m=P.m)),M}function It(C,M){return C&&M?(0,K.wp)(M)?nt(C,{},M,!1,!1):(0,K.l9)(M)?function Mt(C,M,P,v,N){const A=function at(C,M,P,v){const N=[],A=P?v?X:B:v?B:V;for(let z=0;z<M.length;z++){const k=$(C,A,M[z]);k&&k.length>=2&&N.push(k)}return N.length?N:null}(C,P.paths,v,N);return A?(M.paths=A,M):null}(C,{},M,!1,!1):(0,K.oU)(M)?function bt(C,M,P,v,N){const A=function it(C,M,P,v){const N=[],A=P?v?X:B:v?B:V;for(let z=0;z<M.length;z++){const k=$(C,A,M[z]);k&&k.length>=3&&N.push(k)}return N.length?N:null}(C,P.rings,v,N);return A?(M.rings=A,M):null}(C,{},M,!1,!1):(0,K.aW)(M)?function xt(C,M,P,v,N){return M.points=function tt(C,M,P,v){return $(C,P?v?X:B:v?B:V,M)}(C,P.points,v,N),M}(C,{},M,!1,!1):(0,K.YX)(M)?function ct(C,M,P,v,N){return M.xmin=Y(C,P.xmin),M.ymin=J(C,P.ymin),M.xmax=Y(C,P.xmax),M.ymax=J(C,P.ymax),M!==P&&(v&&(M.zmin=P.zmin,M.zmax=P.zmax),N&&(M.mmin=P.mmin,M.mmax=P.mmax)),M}(C,{},M,!1,!1):null:null}function Pt(C,M,P,v,N){return(0,Q.pC)(P)&&(M.points=function ot(C,M,P,v){return et(C,P?v?X:B:v?B:V,M)}(C,P.points,v,N)),M}function ft(C,M,P,v,N){return(0,Q.Wi)(P)||(M.x=w(C,P.x),M.y=O(C,P.y),M!==P&&(v&&(M.z=P.z),N&&(M.m=P.m))),M}function Ft(C,M,P,v,N){return(0,Q.pC)(P)&&(M.rings=function ut(C,M,P,v){return W(C,P?v?X:B:v?B:V,M)}(C,P.rings,v,N)),M}function vt(C,M,P,v,N){return(0,Q.pC)(P)&&(M.paths=function dt(C,M,P,v){return W(C,P?v?X:B:v?B:V,M)}(C,P.paths,v,N)),M}},46089:(j,D,T)=>{T.r(D),T.d(D,{default:()=>kt});var Q=T(94573),K=T(62208),_=T(86236),V=T(65234),B=T(33696),rt=(T(8314),T(5548)),mt=T(65401),$=(T(7848),T(71774),T(36255));class ut{constructor(a,I,F){this.uid=a,this.geometry=I,this.attributes=F,this.visible=!0,this.objectId=null,this.centroid=null}}class yt{constructor(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null}}(0,rt.Ue)(),(0,mt.Ue)();var P=T(82054);function v(c,a){return a}function N(c,a,I,F){switch(I){case 0:return S(c,a+F,0);case 1:return"lowerLeft"===c.originPosition?S(c,a+F,1):function L({translate:c,scale:a},I,F){return c[F]-I*a[F]}(c,a+F,1)}}function A(c,a,I,F){return 2===I?S(c,a,2):N(c,a,I,F)}function z(c,a,I,F){return 2===I?S(c,a,3):N(c,a,I,F)}function k(c,a,I,F){return 3===I?S(c,a,3):A(c,a,I,F)}function S({translate:c,scale:a},I,F){return c[F]+I*a[F]}class H{constructor(a){this.options=a,this.geometryTypes=["point","multipoint","polyline","polygon"],this.previousCoordinate=[0,0],this.transform=null,this.applyTransform=v,this.lengths=[],this.currentLengthIndex=0,this.toAddInCurrentPath=0,this.vertexDimension=0,this.coordinateBuffer=null,this.coordinateBufferPtr=0,this.AttributesConstructor=function(){}}createFeatureResult(){return new yt}finishFeatureResult(a){if(this.options.applyTransform&&(a.transform=null),this.AttributesConstructor=function(){},this.coordinateBuffer=null,this.lengths.length=0,!a.hasZ)return;const I=(0,B.k)(a.geometryType,this.options.sourceSpatialReference,a.spatialReference);if(!(0,K.Wi)(I))for(const F of a.features)I(F.geometry)}createSpatialReference(){return new V.Z}addField(a,I){a.fields.push($.Z.fromJSON(I));const F=a.fields.map(R=>R.name);this.AttributesConstructor=function(){for(const R of F)this[R]=null}}addFeature(a,I){const F=this.options.maxStringAttributeLength?this.options.maxStringAttributeLength:0;if(F>0)for(const R in I.attributes){const E=I.attributes[R];"string"==typeof E&&E.length>F&&(I.attributes[R]="")}a.features.push(I)}addQueryGeometry(a,I){const{queryGeometry:F,queryGeometryType:R}=I,E=(0,P.$g)(F.clone(),F,!1,!1,this.transform),U=(0,P.di)(E,R,!1,!1);let G=null;switch(R){case"esriGeometryPoint":G="point";break;case"esriGeometryPolygon":G="polygon";break;case"esriGeometryPolyline":G="polyline";break;case"esriGeometryMultipoint":G="multipoint"}U.type=G,a.queryGeometryType=R,a.queryGeometry=U}prepareFeatures(a){switch(this.transform=a.transform,this.options.applyTransform&&a.transform&&(this.applyTransform=this.deriveApplyTransform(a)),this.vertexDimension=2,a.hasZ&&this.vertexDimension++,a.hasM&&this.vertexDimension++,a.geometryType){case"point":this.addCoordinate=(I,F,R)=>this.addCoordinatePoint(I,F,R),this.createGeometry=I=>this.createPointGeometry(I);break;case"polygon":this.addCoordinate=(I,F,R)=>this.addCoordinatePolygon(I,F,R),this.createGeometry=I=>this.createPolygonGeometry(I);break;case"polyline":this.addCoordinate=(I,F,R)=>this.addCoordinatePolyline(I,F,R),this.createGeometry=I=>this.createPolylineGeometry(I);break;case"multipoint":this.addCoordinate=(I,F,R)=>this.addCoordinateMultipoint(I,F,R),this.createGeometry=I=>this.createMultipointGeometry(I);break;case"mesh":case"extent":break;default:(0,Q.Bg)(a.geometryType)}}createFeature(){return this.lengths.length=0,this.currentLengthIndex=0,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0,new ut((0,_.D)(),null,new this.AttributesConstructor)}allocateCoordinates(){const a=this.lengths.reduce((I,F)=>I+F,0);this.coordinateBuffer=new Float64Array(a*this.vertexDimension),this.coordinateBufferPtr=0}addLength(a,I,F){0===this.lengths.length&&(this.toAddInCurrentPath=I),this.lengths.push(I)}createPointGeometry(a){const I={type:"point",x:0,y:0,spatialReference:a.spatialReference,hasZ:!!a.hasZ,hasM:!!a.hasM};return I.hasZ&&(I.z=0),I.hasM&&(I.m=0),I}addCoordinatePoint(a,I,F){switch(I=this.applyTransform(this.transform,I,F,0),F){case 0:a.x=I;break;case 1:a.y=I;break;case 2:a.hasZ?a.z=I:a.m=I;break;case 3:a.m=I}}transformPathLikeValue(a,I){let F=0;return I<=1&&(F=this.previousCoordinate[I],this.previousCoordinate[I]+=a),this.applyTransform(this.transform,a,I,F)}addCoordinatePolyline(a,I,F){this.dehydratedAddPointsCoordinate(a.paths,I,F)}addCoordinatePolygon(a,I,F){this.dehydratedAddPointsCoordinate(a.rings,I,F)}addCoordinateMultipoint(a,I,F){0===F&&a.points.push([]);const R=this.transformPathLikeValue(I,F);a.points[a.points.length-1].push(R)}createPolygonGeometry(a){return{type:"polygon",rings:[[]],spatialReference:a.spatialReference,hasZ:!!a.hasZ,hasM:!!a.hasM}}createPolylineGeometry(a){return{type:"polyline",paths:[[]],spatialReference:a.spatialReference,hasZ:!!a.hasZ,hasM:!!a.hasM}}createMultipointGeometry(a){return{type:"multipoint",points:[],spatialReference:a.spatialReference,hasZ:!!a.hasZ,hasM:!!a.hasM}}dehydratedAddPointsCoordinate(a,I,F){0===F&&0==this.toAddInCurrentPath--&&(a.push([]),this.toAddInCurrentPath=this.lengths[++this.currentLengthIndex]-1,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0);const R=this.transformPathLikeValue(I,F);0===F&&a[a.length-1].push(new Float64Array(this.coordinateBuffer.buffer,this.coordinateBufferPtr*Float64Array.BYTES_PER_ELEMENT,this.vertexDimension)),this.coordinateBuffer[this.coordinateBufferPtr++]=R}deriveApplyTransform(a){const{hasZ:I,hasM:F}=a;return I&&F?k:I?A:F?z:N}}var q=T(85262);class zt{_parseFeatureQuery(a){const I=(0,q.C)(a.buffer,new H(a.options)),F=Tt(Rt({},I),{spatialReference:I.spatialReference.toJSON(),fields:I.fields?I.fields.map(R=>R.toJSON()):void 0});return Promise.resolve(F)}}function kt(){return new zt}}}]);