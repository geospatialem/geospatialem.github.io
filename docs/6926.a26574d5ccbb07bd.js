"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[6926],{80355:(xt,rt,C)=>{C.d(rt,{KC:()=>z,QI:()=>ot,wF:()=>M,K:()=>w,Yx:()=>X,nb:()=>x,BH:()=>at,NL:()=>N,Tg:()=>J});var H=C(2076),mt=C(62208),V=C(60295),q=C(77692);const F=new Map;F.set("meter-per-second",1),F.set("kilometer-per-hour",.277778),F.set("knots",.514444),F.set("feet-per-second",.3048),F.set("mile-per-hour",.44704);const G=180/Math.PI,N=new H.Xn({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function X(t,r){return F.get(t)/F.get(r)||1}function tt(t){return(450-t)%360}function J(t,r="geographic"){const[n,e]=t,a=Math.sqrt(n*n+e*e);let o=Math.atan2(e,n)*G;return o=(360+o)%360,"geographic"===r&&(o=tt(o)),[a,o]}function et(t,r="geographic"){let n=t[1];"geographic"===r&&(n=tt(n)),n%=360;const e=t[0];return[e*Math.cos(n/G),e*Math.sin(n/G)]}function z(t,r,n="geographic",e=1){if(!(0,q.nk)(t))return t;const{pixels:a,width:o,height:c}=t,f=o*c,g=a[0],i=a[1],h=V.Z.createEmptyBand(t.pixelType,f),s=V.Z.createEmptyBand(t.pixelType,f);let l=0;for(let p=0;p<c;p++)for(let y=0;y<o;y++)"vector-uv"===r?([h[l],s[l]]=J([g[l],i[l]],n),h[l]*=e):([h[l],s[l]]=et([g[l],i[l]],n),h[l]*=e,s[l]*=e),l++;const d=new V.Z({pixelType:t.pixelType,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:[h,s]});return d.updateStatistics(),d}function ot(t,r,n=1){if(1===n||!(0,q.nk)(t))return t;const e=t.clone(),{pixels:a,width:o,height:c}=e,f=a[0],g=a[1];let i=0;for(let h=0;h<c;h++)for(let s=0;s<o;s++)"vector-uv"===r?(f[i]*=n,g[i]*=n):f[i]*=n,i++;return e.updateStatistics(),e}function at(t,r,n,e,a){if(!(0,mt.pC)(a)||!a.spatialReference.equals(t.spatialReference))return{extent:t,width:r,height:n,resolution:t.width/r};const o=a.xmin,c=a.ymax;e=Math.max(e||0,30);const f=Math.ceil(r*(1/e)),g=Math.ceil(n*(1/e)),i=((t.xmax-t.xmin)/f+(t.ymax-t.ymin)/g)/2;return t.xmin=o+Math.floor((t.xmin-o)/i)*i,t.xmax=o+Math.ceil((t.xmax-o)/i)*i,t.ymin=c+Math.floor((t.ymin-c)/i)*i,t.ymax=c+Math.ceil((t.ymax-c)/i)*i,{extent:t,width:Math.round(t.width/i),height:Math.round(t.height/i),resolution:i}}const Q=function it(t=0,r=0,n=Math.PI,e=!0){e&&(n=(2*Math.PI-n)%(2*Math.PI));const a=e?-1:1,o=13*a,c=-7*a,f=-2*a,g=-16*a,i=29,[h,s]=L(0,r+o,n,i),[l,d]=L(t-5.5,r+c,n,i),[p,y]=L(t+5.5,r+c,n,i),[I,T]=L(t-1.5,r+f,n,i),[O,P]=L(t+1.5,r+f,n,i),[U,D]=L(t-1.5,r+g,n,i),[E,k]=L(t+1.5,r+g,n,i);return[h,s,l,d,I,T,O,P,p,y,U,D,E,k]}(0,0,0);function st(t=0,r=Math.PI,n=!0){n&&(r=(2*Math.PI-r)%(2*Math.PI));const a=n?-1:1,o=5*a,c=20*a,f=25*a,g=45,d=2*a;let[p,y]=[5,0-c],[I,T]=[p+2,y],[O,P]=[I-0,T+d],[U,D]=[-5,0-f],[E,k]=[U+0,D-d],b=Math.ceil(t/5),A=Math.floor(b/10);b-=8*A;const v=[],B=[];for(let ut=0;ut<b/2;ut++,A--){A<=0&&b%2==1&&ut===(b-1)/2&&(U=0,E=U+0,D=(D+y)/2,k=D-d);const[Mt,gt]=L(U,D,r,g);if(A>0){const[ft,dt]=L(I,D,r,g),[pt,_t]=L(p,y,r,g);v.push(ft),v.push(dt),v.push(Mt),v.push(gt),v.push(pt),v.push(_t)}else{const[ft,dt]=L(I,T,r,g),[pt,_t]=L(O,P,r,g),[Et,At]=L(E,k,r,g);B.push(Mt),B.push(gt),B.push(Et),B.push(At),B.push(pt),B.push(_t),B.push(ft),B.push(dt)}D+=o,y+=o,T+=o,P+=o,k+=o}const[W,j]=L(5,0+c,r,g),[nt,ht]=L(7,0+c,r,g),[ct,wt]=L(5,0-f,r,g),[yt,Pt]=L(7,0-f,r,g);return{pennants:v,barbs:B,shaft:[W,j,nt,ht,ct,wt,yt,Pt]}}function L(t,r,n,e=1){const a=Math.sqrt(t*t+r*r)/e,o=(2*Math.PI+Math.atan2(r,t))%(2*Math.PI);return[a,(2*Math.PI+o-n)%(2*Math.PI)]}const K=[0,1,3,6,10,16,21,27,33,40,47,55,63],lt=[0,.5,1,1.5,2],Y=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function R(t,r,n,e){const a=X(e||"knots",n);let o;for(o=1;o<r.length;o++)if(o===r.length-1){if(t<r[o]*a)break}else if(t<=r[o]*a)break;return Math.min(o-1,r.length-2)}function $(t,r,n,e,a){let o=0;switch(r){case"beaufort_kn":o=R(t,K,"knots",n);break;case"beaufort_km":o=R(t,K,"kilometer-per-hour",n);break;case"beaufort_ft":o=R(t,K,"feet-per-second",n);break;case"beaufort_m":o=R(t,K,"meter-per-second",n);break;case"classified_arrow":o=R(t,a,e,n);break;case"ocean_current_m":o=R(t,lt,"meter-per-second",n);break;case"ocean_current_kn":o=R(t,Y,"knots",n)}return o}const u=[];function w(t,r){let e=0,a=0;const{width:o,height:c,mask:f}=t,g=t.pixels[0],i=[],h=[],s="wind_speed"===r.style?5:Number.MAX_VALUE;for(let l=0;l<c;l++)for(let d=0;d<o;d++){const p=l*o+d;if((!f||f[l*o+d])&&g[p]<s){for(let I=0;I<4;I++)i[e++]=(d+.5)/o,i[e++]=(l+.5)/c,i[e++]=I<2?-.5:.5,i[e++]=I%2==0?-.5:.5,i[e++]=0,i[e++]=g[p];const y=4*(e/24-1);h[a++]=y,h[a++]=y+1,h[a++]=y+2,h[a++]=y+1,h[a++]=y+2,h[a++]=y+3}}return{vertexData:new Float32Array(i),indexData:new Uint32Array(h)}}function M(t,r){return"simple_scalar"===r.style?w(t,r):"wind_speed"===r.style?function m(t,r){if(0===u.length)for(let p=0;p<30;p++)u.push(st(5*p,0));const n=X(N.fromJSON(r.inputUnit),"knots"),{width:e,height:a,mask:o}=t,c=t.pixels[0],f=t.pixels[1],i=[],h=[];let s=0,l=0;for(let p=0;p<a;p++)for(let y=0;y<e;y++){const I=p*e+y,T=c[I]*n;if((!o||o[p*e+y])&&T>=5){var d;const O=null!=(d=(f[I]+360)%360/180*Math.PI)?d:2*Math.PI*Math.random(),{pennants:P,barbs:U,shaft:D}=u[Math.min(Math.floor(T/5),29)];if(P.length+U.length===0)continue;let E=i.length/6;const k=(y+.5)/e,b=(p+.5)/a;for(let A=0;A<P.length;A+=2)i[s++]=k,i[s++]=b,i[s++]=P[A],i[s++]=P[A+1]+O,i[s++]=0,i[s++]=T;for(let A=0;A<U.length;A+=2)i[s++]=k,i[s++]=b,i[s++]=U[A],i[s++]=U[A+1]+O,i[s++]=0,i[s++]=T;for(let A=0;A<D.length;A+=2)i[s++]=k,i[s++]=b,i[s++]=D[A],i[s++]=D[A+1]+O,i[s++]=0,i[s++]=T;for(let A=0;A<P.length/6;A++)h[l++]=E,h[l++]=E+1,h[l++]=E+2,E+=3;for(let A=0;A<U.length/8;A++)h[l++]=E,h[l++]=E+1,h[l++]=E+2,h[l++]=E+1,h[l++]=E+2,h[l++]=E+3,E+=4;h[l++]=E+0,h[l++]=E+1,h[l++]=E+2,h[l++]=E+1,h[l++]=E+3,h[l++]=E+2,E+=4}}return{vertexData:new Float32Array(i),indexData:new Uint32Array(h)}}(t,r):function _(t,r){const{style:n,inputUnit:e,outputUnit:a,breakValues:o}=r,c=N.fromJSON(e),f=N.fromJSON(a);let h=0,s=0;const{width:l,height:d,mask:p}=t,y=t.pixels[0],I=t.pixels[1],T=p?p.filter(D=>D>0).length:l*d,O=new Float32Array(42*T),P=new Uint32Array(15*T);for(let D=0;D<d;D++)for(let E=0;E<l;E++){const k=D*l+E;if(!p||p[D*l+E]){var U;const b=null!=(U=(I[k]+360)%360/180*Math.PI)?U:2*Math.PI*Math.random(),A=$(y[k],n,c,f,o);for(let B=0;B<Q.length;B+=2)O[h++]=(E+.5)/l,O[h++]=(D+.5)/d,O[h++]=Q[B],O[h++]=Q[B+1]+b,O[h++]=A,O[h++]=y[k];const v=7*(h/42-1);P[s++]=v,P[s++]=v+1,P[s++]=v+2,P[s++]=v+0,P[s++]=v+4,P[s++]=v+3,P[s++]=v+0,P[s++]=v+2,P[s++]=v+3,P[s++]=v+2,P[s++]=v+5,P[s++]=v+3,P[s++]=v+5,P[s++]=v+6,P[s++]=v+3}}return{vertexData:O,indexData:P}}(t,r)}function x(t,r,n,e=[0,0],a=.5){const{width:o,height:c,mask:f}=t,[g,i]=t.pixels,[h,s]=e,l=Math.round((o-h)/n),d=Math.round((c-s)/n),p=l*d,y=new Float32Array(p),I=new Float32Array(p),T=new Uint8Array(p),O="vector-uv"===r;for(let U=0;U<d;U++)for(let D=0;D<l;D++){let E=0;const k=U*l+D,b=Math.max(0,U*n+s),A=Math.max(0,D*n+h),v=Math.min(c,b+n),B=Math.min(o,A+n);for(let W=b;W<v;W++)for(let j=A;j<B;j++){const S=W*o+j;if(!f||f[S]){E++;const nt=O?[g[S],i[S]]:[g[S],(360+i[S])%360],[ht,ct]=O?nt:et(nt);y[k]+=ht,I[k]+=ct}}if(E>=(v-b)*(B-A)*(1-a)){T[k]=1;const[W,j]=J([y[k]/E,I[k]/E]);y[k]=W,I[k]=j}else T[k]=0,y[k]=0,I[k]=0}const P=new V.Z({width:l,height:d,pixels:[y,I],mask:T});return P.updateStatistics(),P}},37084:(xt,rt,C)=>{C.d(rt,{z_:()=>et,KK:()=>lt});var H=C(15861),V=(C(29132),C(63290)),q=C(21286),F=C(62208),G=C(10699),Z=C(4619),N=C(37053),X=C(2004);const tt=V.Z.getLogger("esri.views.2d.engine.flow.dataUtils");function et(_,u,m){return z.apply(this,arguments)}function z(){return(z=(0,H.Z)(function*(_,u,m){const w=performance.now(),M=ot(_,u),x=performance.now(),t=Q(_,M,u.width,u.height),r=performance.now(),n=st(t,!0),e=performance.now(),a=L(n),o=performance.now();if(_.profile){const c={"_createFlowFieldFromData()":Math.round(x-w),"_getStreamlines()":Math.round(r-x),"createAnimatedLinesData()":Math.round(e-r),"createLinesMesh()":Math.round(o-e),"Total elapsed time":Math.round(o-w)};tt.info("createStreamlinesMesh profile",c)}return yield Promise.resolve(),(0,G.k_)(m),a})).apply(this,arguments)}function ot(_,u){const m=function it(_,u,m,w){if(0===w)return _;const M=Math.round(3*w),x=new Array(2*M+1);let t=0;for(let e=-M;e<=M;e++){const a=Math.exp(-e*e/(w*w));x[e+M]=a,t+=a}for(let e=-M;e<=M;e++)x[e+M]/=t;const r=new Float32Array(_.length);for(let e=0;e<m;e++)for(let a=0;a<u;a++){let o=0,c=0;for(let f=-M;f<=M;f++){if(a+f<0||a+f>=u)continue;const g=x[f+M];o+=g*_[2*(e*u+(a+f))+0],c+=g*_[2*(e*u+(a+f))+1]}r[2*(e*u+a)+0]=o,r[2*(e*u+a)+1]=c}const n=new Float32Array(_.length);for(let e=0;e<u;e++)for(let a=0;a<m;a++){let o=0,c=0;for(let f=-M;f<=M;f++){if(a+f<0||a+f>=m)continue;const g=x[f+M];o+=g*r[2*((a+f)*u+e)+0],c+=g*r[2*((a+f)*u+e)+1]}n[2*(a*u+e)+0]=o,n[2*(a*u+e)+1]=c}return n}(u.data,u.width,u.height,_.smoothing);return _.interpolate?(w,M)=>{const x=Math.floor(w),t=Math.floor(M);if(x<0||x>=u.width)return[0,0];if(t<0||t>=u.height)return[0,0];const r=w-x,n=M-t,o=x<u.width-1?x+1:x,c=t<u.height-1?t+1:t;return[(m[2*(t*u.width+x)]*(1-n)+m[2*(c*u.width+x)]*n)*(1-r)+(m[2*(t*u.width+o)]*(1-n)+m[2*(c*u.width+o)]*n)*r,(m[2*(t*u.width+x)+1]*(1-n)+m[2*(c*u.width+x)+1]*n)*(1-r)+(m[2*(t*u.width+o)+1]*(1-n)+m[2*(c*u.width+o)+1]*n)*r]}:(w,M)=>{const x=Math.round(w),t=Math.round(M);return x<0||x>=u.width||t<0||t>=u.height?[0,0]:[m[2*(t*u.width+x)+0],m[2*(t*u.width+x)+1]]}}function at(_,u,m,w,M,x,t,r,n){const e=[];let a,o,c=m,f=w,g=0;e.push({x:c,y:f,t:g});for(let i=0;i<_.verticesPerLine;i++){let[h,s]=u(c,f);h*=_.velocityScale,s*=_.velocityScale;const l=Math.sqrt(h*h+s*s);if(l<_.minSpeedThreshold)return e;const d=h/l,p=s/l;if(c+=d*_.segmentLength,f+=p*_.segmentLength,g+=_.segmentLength/l,Math.acos(d*a+p*o)>_.maxTurnAngle)return e;if(_.mergeLines){const y=Math.round(c*n),I=Math.round(f*n);if(y<0||y>t-1||I<0||I>r-1)return e;const T=x[I*t+y];if(-1!==T&&T!==M)return e;x[I*t+y]=M}e.push({x:c,y:f,t:g}),a=d,o=p}return e}function Q(_,u,m,w){const M=[],x=new Z.Z,t=1/Math.max(_.lineCollisionWidth,1),r=Math.round(m*t),n=Math.round(w*t),e=new Int32Array(r*n);for(let o=0;o<e.length;o++)e[o]=-1;const a=[];for(let o=0;o<w;o+=_.lineSpacing)for(let c=0;c<m;c+=_.lineSpacing)a.push({x:c,y:o,sort:x.getFloat()});a.sort((o,c)=>o.sort-c.sort);for(const{x:o,y:c}of a)if(x.getFloat()<_.density){const f=at(_,u,o,c,M.length,e,r,n,t);if(f.length<2)continue;M.push(f)}return M}function st(_,u){const m=new Z.Z,w=_.reduce((n,e)=>n+e.length,0),M=new Float32Array(3*w),x=new Array(_.length);let t=0,r=0;for(const n of _){const e=t;for(const a of n)M[3*t+0]=a.x,M[3*t+1]=a.y,M[3*t+2]=a.t,t++;x[r++]={startVertex:e,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:u?m.getFloat():0}}return{lineVertices:M,lineDescriptors:x}}function L(_,u=10){const{lineVertices:m,lineDescriptors:w}=_;let M=0,x=0;for(const c of w)M+=2*c.numberOfVertices,x+=6*(c.numberOfVertices-1);const t=new Float32Array(8*M),r=new Uint32Array(x);let n=0,e=0;function o(c,f,g,i,h,s,l){const d=8*n;let p=0;t[d+p++]=c,t[d+p++]=f,t[d+p++]=1,t[d+p++]=g,t[d+p++]=s,t[d+p++]=l,t[d+p++]=i,t[d+p++]=h,n++,t[d+p++]=c,t[d+p++]=f,t[d+p++]=-1,t[d+p++]=g,t[d+p++]=s,t[d+p++]=l,t[d+p++]=-i,t[d+p++]=-h,n++}for(const c of w){const{totalTime:f,timeSeed:g}=c;let i=null,h=null,s=null,l=null,d=null;for(let p=0;p<c.numberOfVertices;p++){const y=m[3*(c.startVertex+p)+0],I=m[3*(c.startVertex+p)+1],T=m[3*(c.startVertex+p)+2];let O=null,P=null,U=null,D=null;if(p>0){O=y-i,P=I-h;const E=Math.sqrt(O*O+P*P);if(O/=E,P/=E,p>1){let k=O+l,b=P+d;const A=Math.sqrt(k*k+b*b);k/=A,b/=A;const v=Math.min(1/(k*O+b*P),u);k*=v,b*=v,U=-b,D=k}else U=-P,D=O;null!==U&&null!==D&&(o(i,h,s,U,D,f,g),r[e++]=n-2,r[e++]=n,r[e++]=n-1,r[e++]=n,r[e++]=n+1,r[e++]=n-1)}i=y,h=I,s=T,l=O,d=P}o(i,h,s,-d,l,f,g)}return{vertexData:t,indexData:r}}function K(_,u){const m=u.pixels,{width:w,height:M}=u,x=new Float32Array(w*M*2);if("vector-uv"===_)for(let t=0;t<w*M;t++)x[2*t+0]=m[0][t],x[2*t+1]=-m[1][t];else if("vector-magdir"===_)for(let t=0;t<w*M;t++){const r=m[0][t],n=(0,q.Vl)(m[1][t]),e=Math.cos(n-Math.PI/2),a=Math.sin(n-Math.PI/2);x[2*t+0]=e*r,x[2*t+1]=a*r}return{data:x,width:w,height:M}}function lt(_,u,m,w,M){return Y.apply(this,arguments)}function Y(){return(Y=(0,H.Z)(function*(_,u,m,w,M){const x=(0,N.C5)(u.spatialReference);if(!x)return R(_,u,m,w,M);const[t,r]=x.valid,e=Math.ceil(u.width/(r-t)),a=u.width/e,o=Math.round(m/e);let c=u.xmin;const f=[];for(let s=0;s<e;s++){const l=new X.Z({xmin:c,xmax:c+a,ymin:u.ymin,ymax:u.ymax,spatialReference:u.spatialReference});f.push(R(_,l,o,w,M)),c+=a}const g=yield Promise.all(f),i={data:new Float32Array(m*w*2),width:m,height:w};let h=0;for(const s of g){for(let l=0;l<s.height;l++)for(let d=0;d<s.width;d++)h+d>=m||(i.data[2*(l*m+h+d)+0]=s.data[2*(l*s.width+d)+0],i.data[2*(l*m+h+d)+1]=s.data[2*(l*s.width+d)+1]);h+=s.width}return i})).apply(this,arguments)}function R(_,u,m,w,M){return $.apply(this,arguments)}function $(){return($=(0,H.Z)(function*(_,u,m,w,M){if("imagery"===_.type){yield _.load({signal:M});const r=_.rasterInfo.dataType,n=yield _.fetchImage(u,m,w,{signal:M});return!n||(0,F.Wi)(n.pixelData)||(0,F.Wi)(n.pixelData.pixelBlock)?{data:new Float32Array(m*w*2),width:m,height:w}:K(r,n.pixelData.pixelBlock)}yield _.load({signal:M});const x=_.rasterInfo.dataType,t=yield _.fetchPixels(u,m,w,{signal:M});return!t||(0,F.Wi)(t.pixelBlock)?{data:new Float32Array(m*w*2),width:m,height:w}:K(x,t.pixelBlock)})).apply(this,arguments)}}}]);